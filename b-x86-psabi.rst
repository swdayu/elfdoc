x86 补充规范

* `底层机器接口`_

  * `处理器架构`_
  * `数据表示`_
  * `位域`_

* `函数调用约定`_

  * `寄存器`_
  * `栈帧`_
  * `传参`_
  * `可变参数传递`_
  * `返回值`_

* `操作系统接口`_

  * `虚拟地址空间`_
  * `处理器执行模式`_
  * `异常接口`_
  * `进程初始化`_
  * `栈展开算法`_

* `代码示例`_

  * `代码模型`_
  * `位置无关函数起始代码`_
  * `数据对象`_
  * `函数调用`_
  * `分支跳转`_
  * `C 栈帧`_

* `目标文件`_

  * `文件头部`_
  * `特殊分区`_
  * `符号表分区`_
  * `重定位类型`_

* `程序加载`_

* `动态链接`_

  * `程序解释器`_
  * `动态链接段`_
  * `全局偏移表`_
  * `函数地址`_
  * `过程链接表`_

底层机器接口
=============

处理器架构
----------

Intel 80386 程序员参考手册（Intel 文献序号 230985）和 Intel 80387 程序员参考手册（Intel
文献序号 231917）共同定义了处理器架构。组合的 Intel386/Intel387 处理器架构此后被称为
Intel386 架构。直接在该处理器上执行的程序意味着使用该架构的指令集、指令编码和指令语义。
有三点需要明确指出的是：

1. 一个程序可以假定所有记录在文档中的指令都是存在的
2. 一个程序可以假定所有记录在文档中的指令都是工作的
3. 一个程序只可以使用由架构定义的指令

换句话说，从程序的角度来看，执行环境提供了一个完整且正常工作的 Intel386 架构实现。这并
不意味着底层实现以硬件形式提供了所有指令，只是这些指令执行了指定的操作并产生了指定的结果。
ABI（应用程序二进制接口）既不对系统的执行性能施加限制，也没有指定必须以硬件形式实现哪些
指令。符合 ABI 的架构软件仿真是可能的。

一些处理器可能作仅支持 Intel386 架构的一个子集，或者提供额外的指令或功能。显式使用这些
功能的程序不符合 Intel386 ABI。在没有支持这些额外功能的机器上执行这种程序将导致未定义的
行为。

数据表示
---------

本规范中，halfword 表示的是16位大小的对象，word 表示32位大小的对象，doubleword 表示64
位大小的对象。或者可以使用 twobyte、fourbyte、eightbyte 表示。以下是 C 语言中的基本类
型与处理器类型的对应关系和信息： ::

    C 语言类型                                      大小和对齐  Intel386
    _Bool                                           1   1       boolean
    char/signed char/unsigned char                  1   1       byte
    short/signed short/unsigned short               2   2       twobyte (halfword)
    int/signed int/enum/unsigned int                4   4       fourbyte (word)
    long/signed long/unsigned long                  4   4       fourbyte (word)
    long long/signed long long/unsigned long long   8   4       eightbyte (doubleword)
    any-type*/any-type(*)()                         4   4       fourbyte
    float                                           4   4       single (IEEE-754)
    double/long double††††                          8   4       double (IEEE-754)
    __float80/long double††††                       12  4       80-bit extended (IEEE-754)
    __float128                                      16  16      128-bit extended (IEEE-754)
    _Complex float                                  8   4       complex single (IEEE-754)
    _Complex double/_Complex long double††††        16  4       complex double (IEEE-754)
    _Complex __float80/_Complex long double††††     24  4       complex 80-bit extended (IEEE-754)
    _Complex __float128                             32  16      complex 128-bit extended (IEEE-754)
    _Decimal32                                      4   4       32bit BID (IEEE-754R)
    _Decimal64                                      8   8       64bit BID (IEEE-754R)
    _Decimal128                                     16  16      128bit BID (IEEE-754R)
    __m64                                           8   8       MMX and 3DNow!
    __m128                                          16  16      SSE and SSE-2
    __m256                                          32  32      AVX
    __m512                                          64  64      AVX-512

    †††† 类型 long double 在 Android 平台上与 double 相同，都是 8 字节

Intel386 架构不需要双精度浮点值是8字节对齐的，但是为了兼容 x64 的数据结构，编译器可以将
它对齐到8字节边界。然而，这样生成的代码（包括数据结构和函数调用约定）是与 Intel386 ABI
不兼容的，违反了 Intel386 ABI。

80位浮点使用15位指数（exponent），64位尾数（mantissa），最高有效位是隐含的，指数的偏移
量为 16383。128位浮点使用15位指数，113位尾数，最高有效位是隐含的，指数的偏移量为 16383。
Intel386 架构的最初实现仅通过软件仿真来支持128位浮点类型的操作。

类型 size_t 被定义为 unsigned int。布尔类型当保存在内存中时，长度为1个字节，其值为 0
表示 false，1 表示 true。当存储在整型寄存器中时（除非传递参数），寄存器中所有 4 个字节
都是重要的，并且任何非零值都表示 true。

Intel386 并不需要所有的类型都是根据字节大小对齐的，对齐的数据访问速度只是比不对齐的快，
其他行为都是相同的。仅有的例外是 __float128、_Complex __float128、_Decimal128、__m128、
__m256、__m512 必须是严格对齐的。

结构体和联合体的对齐字节数是其成员的最大对齐地址数，每个成员位于满足对齐要求的最低偏移处。
任何对象的大小必须是对象对齐字节数的倍数。结构体和联合体可以通过填充来满足大小和对齐要求，
填充内容没有定义。因为成员对齐产生的填充称为内部填充（internal padding）。因为对象整体
大小必须是对象对齐字节整数倍产生的填充称为尾部填充（tail padding），与最后一个成员的大
小相关。下面是两种填充的例子： ::

    struct { // 结构体4字节对齐，大小16字节
        char c;
        double d;
        short s;
    };

      byte 3 | byte 2 | byte 1 | byte 0
    [    internal padding      |   c   ]
    [                 d                ]
    [                 d                ]
    [   tail padding  |        s       ]

位域
-----

C 语言中的结构体和联合体可以包含位域成员，它定义一个指定了比特位宽度的整型数据。位域类型
成员的值范围： ::

    位域类型                        比特位宽度（w）范围     值范围
    signed char/short/int/long          1 ~ 8/16/32     -2^(w-1) ~ 2^(w-1)-1
    char/unsigned char                  1 ~ 8           0 ~ (2^w)-1
    short/unsigned short                1 ~ 16          0 ~ (2^w)-1
    int/long/enum/unsigned int/long     1 ~ 32          0 ~ (2^w)-1

不加修饰的整型位域总是非负值，即使对应的类型 char、short、int、long 可以设置负值，但是
位域的结果总是与对应的 unsigned 类型相同。位域成员的大小和对齐规则与结构体或联合体成员
相同，并补充以下几点：

1. 位域按照定义顺序从地址最低位到最高位分配
2. 位域字段必须完全位域对应类型的存储单元内，不能跨越边界
3. 位域字段可以与其他成员共享存储单元，其他成员包括非位域成员，当然结构体成员占据存储单
   元的不同部分
4. 未命名位域成员不影响结构体或联合体的对齐，尽管位域字段的成员偏移需要满足对齐要求
5. 使用 int 类型位域最紧凑，它的成员偏移不需要对齐；而 char/short 类型位域不仅起始位置
   需要对齐，如果其后还有更多的成员，每个 char/short 类型位域必须占满一个 char/short

包含位域成员的结构体例子： ::

    struct {        // 结构体4字节对齐，大小是4字节
        int j:5;    // bit4 ~ bit0
        int k:6;    // bit10 ~ bit5
        int m:7;    // bit17 ~ bit11
    };              // bit31 ~ bit18 填充

    struct {        // 结构体4字节对齐，大小12字节
        short s:9;  // word0: bit8 ~ bit0
        int   j:9;  //        bit17 ~ bit9
                    //        bit23 ~ bit18 填充
        char  c;    //        byte3
        short t:9;  // word1: bit8 ~ bit0
                    //        bit15 ~ bit9 填充
        short u:9;  //        bit24 ~ bit16
                    //        bit31 ~ bit25
        char  d;    // word3: byte0
    };              //        byte3 ~ byte1 填充

    struct {        // 结构体2字节对齐，大小2字节
        char  c;    // byte0
        short s:8;  // byte1
    };

    struct {        // 结构体1字节对齐，大小9字节
        char  c;    // word0: byte0
        int   :0;   //        byte3 ~ byte1
        char  d;    // word1: byte0
                    //        byte1 填充
        short :9;   //        bit24 ~ bit16
                    //        bit31 ~ bit25 填充
        char  e;    // word2: byte0
        char  :0;   //        不占位置，因为没有下一个成员
    };

上例所示，int 型位域成员（包括 singed 和 unsigned）比更小的基本类型更紧凑。可以使用字
符型和短整型来强制特定的对齐，但 int 型通常更加高效。未命名位域表示的是，下一个成员必须
对齐到对应类型地址对齐要求的边界。

函数调用约定
=============

这部分介绍标准函数调用约定，包括栈帧布局、寄存器使用、参数传递等等。标准调用约定仅用于全
局函数。本地不会被其他编译单元访问的函数可以适用不同的约定，但还是推荐所有的函数都是用标
准调用约定。

寄存器
-------

Intel386 提供了一系列寄存器，整型寄存器和浮点寄存器简要描述如下： ::

    通用寄存器       用途                                         是否由被调函数保护可自动跨函数使用
    %eax            临时寄存器（scratch register），返回值                        否
    %ebx            本地寄存器（local register），当 PLT 调用函数时保存 GOT 指针  （是）
    %ecx            临时寄存器，计数寄存器（移位和字符串操作）                      否
    %edx            临时寄存器，被除数寄存器（除法操作），还用来返回高32位           否
    %ebp            栈基指针（可选）                                            （是）
    %esi            本地寄存器                                                 （是）
    %edi            本地寄存器                                                 （是）
    %esp            栈顶指针                                                   （是）
    %eflags         状态标记
    浮点寄存器
    %st(0) %mm0     临时寄存器，浮点栈顶，返回值                                   否
    %st(1) %mm1 ... 临时寄存器，浮点栈中                                          否
    %st(7) %mm7     临时寄存器，浮点栈底                                          否
    %fcw            浮点控制寄存器                                              （是）
    %fsw            浮点状态寄存器                                               否
    %gs             系统保留（作为线程特定数据寄存器）                             否
    单指多码寄存器
    %xmm0 ~ %xmm7   临时寄存器                                                   否
    %ymm0 ~ %ymm7   临时寄存器                                                   否
    %mxcsr          SSE2 控制位和状态位，只有控制位由被调函数保护                  部分
    %k0 ~ %k7       临时寄存器                                                   否

    mxcsr: media control and status register

CPU 在进入函数之前必须是 x87 模式。因此每个用了 MMX 寄存器的函数，必须在使用完 MMX 寄
存器之后，并在函数返回或调用另一个函数之前，调用 emms 或 femms 指令。所有 x87 寄存器是
由调用者保存的，因此使用 MMX 寄存器的被调函数，可以使用更快的 femms 指令。

状态标记寄存器中的 df 位在函数入口处和返回时必须为 0（即方向向前），即由被调函数保存，可
以跨越函数。其他的标记在标准调用约定中没有指定，没有跨函数保护。MXCSR 寄存器的控制位由被
调函数保存，有跨函数保护；而状态位是由调用者保存的，没有跨函数保护。另外，x87 控制寄存器
是被调函数保存的，而 x87 的状态寄存器是调用者保存的。

Intel386 中的所有寄存器都是全局的，因此对所有调用者和被调函数都是可见的。其中 %ebp、%ebx、
%edi、%esi、%esp 属于调用者，也就是说被调函数使用这些值之前必须为调用者保护这些寄存器。
其余的寄存器属于被调函数，如果调用者需要跨函数使用这些寄存器，必须在调用函数前将这些寄存
器的值保存到它的栈帧里。

栈帧
-----

除了寄存器，每个函数都在运行时栈上有一个栈帧，这个栈从高地址向低地址扩展。下图示意了栈帧
的组织方式： ::

    位置            内容          栈帧
    4n+4(%ebp)      字长参数n    _______ 高地址栈底
                    ...          前一帧
       8(%ebp)      字长参数1    _______
       4(%ebp)      返回地址
       0(%ebp)      原%ebp (O)
      -4(%ebp)      未指定       当前帧
                    ...
       0(%esp)      大小不定     _______ 低地址栈顶

其中输入参数区域的结束位置必须对齐到16字节边界，当使用了 __m256 或 __m512 时必须对应到
32字节或64字节边界。换句话说，当控制权转移到函数入口时，(%esp + 4) 的值必须是16字节或
32字节或64字节的倍数。栈顶指针 %esp 总是指向当前最新分配的栈帧的尾部，即指向已经存有内
容的栈顶元素。使用 %esp 来索引栈帧内容可以避免寄存器 %ebp 作为帧指针使用。这种技术可以
在函数开头和结尾节省两条指令，并节省出一个额外的通用寄存器（%ebp）可用于其他用途。

栈是根据机器字长对齐的。大多数参数会使用栈传递，按照相反的顺序入栈，也就是 C 调用语法中
最左边的参数最后压入地址最低，最右边的参数最先压入地址最高。栈中所有的函数参数位于调用者
的栈帧中，即当前栈帧的前一帧。

参数的大小会在必要时增大，以使其大小为机器字长的倍数，这可能需要尾部填充，具体取决于参数
的大小。栈帧未指定的其他区域，跟编译器和正常被编译的代码相关，标准调用约定没有定义最大的
栈帧大小，也没有限制如果使用标准栈帧中的未指定区域。

在标准调用约定中，一些寄存器赋予了特定的角色：

%esp
    栈指针，指向当前栈帧的最后合法的机器字长地址处，即指向合法的栈顶元素。任何时候，栈顶
    指针都指向一个机器字长对齐的区域。
%ebp
    帧指针，指向当前栈帧的的基地址，也可称为栈基指针。当前函数的参数位于前一个函数的栈帧
    里，使用当前函数的栈基指针和正偏移访问。函数自己的局部变量位于当前栈帧，使用负偏移访
    问。被调函数必须为调用者保护这个寄存器的值。
%eax
    保存整型和指针类型返回值。如果返回值是结构体或联合体，该寄存器保存返回值的地址。否则，
    这是一个临时寄存器。
%ebx
    位置无关代码中，该寄存器用作全局偏移表的基寄存器。对应绝对位置代码，%ebx 用作本地寄
    存器没有特别的角色。但不管哪种情况，必须为调用者保护这个寄存器的值。
%esi %edi
    本地寄存器（local register）没有特别的角色，函数必须为调用者保护这个寄存器的值。
%ecx %edx
    临时寄存器（scratch register），函数不需要为调用者保护这个寄存器。
%st(0)
    浮点返回值位于浮点寄存器栈的栈顶寄存器中，浮点寄存器中的单双扩展精度值的表示都是相同
    的。如果函数不返回一个浮点值，这个寄存器必须为空。在进入一个函数之前，这个寄存器也必
    须为空。
%st(1) ~ %st(7)
    浮点临时寄存器，这些寄存器在进入和退出函数前都必须为空。
EFLAGS
    标记 bf 必须在进入和退出函数前都置为 0，其他标记没有指定特别角色被调函数不需要保护
    这些值。
fcw (control word)
    Intel387 浮点控制寄存器包含一些浮点控制位，例如舍入模式和异常掩码。

信号（Signal）可以打断进程，在信号处理期间调用的函数，其可以使用的寄存器没有特别额外限
制。此外，当信号处理返回之后，进程将恢复其原本执行路径，并恢复寄存器的值。因此，程序和编
译器可以自由使用所有寄存器，而不必担心信号处理程序会修改它们的值。

传参
-----

当所有的参数求值完毕后，它们会被传到寄存器或压到栈中。大多数参数会使用栈传递，并按照相反
顺序入栈。为了满足类型的对齐要求，可能需要使用填充来增加参数的大小。一个列外是，当 __m64
和 _Decimal64 作为参数使用时，只需要对齐到 4 字节。另外还可能需要额外的填充，以使得在参
数之后的栈地址满足16字节地址对齐要求。如果参数中包含需要通过栈传递的 __m256 或者 __m512
类型，由所有通过栈传递的参数组成的结构体必须对齐到32字节或64字节地址处。即 (%esp+4) 的
值必须是16字节或32字节或64字节的倍数。

通过栈传参的例外情况如下：

1. 前 3 个 __m64 类型的参数通过寄存器 %mm0、%mm1、%mm2 传参
2. 前 3 个 __m128 类型的参数通过寄存器 %xmm0、%xmm1、%xmm2 传参
3. 因为 SSE、AVX、AVX-512 寄存器的低位是共享的，第一个 __m128 类型的参数会赋给 %xmm0，
   然后如果还存在第一个 __m256 或 __m512 类型的参数会赋给 %ymm1 或 %zmm1 而不是 %ymm0
   或 %zmm0

通过内存栈传递的参数，第一个参数位于 8(%ebp)，第二个参数位于 12(%ebp)，依次类推。传递
的所有整型参数都会转换成一个字长，将小于字长的参数值的符号位或零比特位扩展到高位。而单精
度浮点适用一个字长，双精度浮点适用两个字长，扩展精度浮点适用三个字长。对于结构体和联合体
参数，每个参数的大小必须扩展到字长的整数倍。

可变参数传递
------------

一些本来可以移植的 C 程序依赖于参数传递方案，隐含地假定所有参数都通过内存栈传递，并且参
数在栈上的顺序是按地址顺序升序排列的。这在 Intel386 上不具备可移植性，因为有些参数是通
过寄存器传递的。为了处理可变参数列表，可移植的 C 程序必须使用头文件 <stdarg.h>。

当调用接受可变参数的函数时，所有参数都通过栈传递，包括 __m64、__m128、__m256 等等。这
一规则适用于命名和未命名参数。由于参数的传递方式取决于被调用函数是否接受可变参数列表，因
此这些函数必须正确地进行声明，不这样做将导致未定义的行为。

返回值
-------

下表列出了每个基本类型返回值以怎样的方式返回。结构体和联合体这些复合类型总是通过内存值返
回。浮点返回值通过 x87 寄存器栈中的栈顶寄存器 %st(0) 返回。调用者需要负责从寄存器栈中弹
出该值，不管该浮点返回值是否真实使用。如果没这样做，将导致未定义行为。这一个要求的一个含
义是，返回浮点值的函数必须正确进行函数原型声明。 当 _Bool 类型值返回或者通过寄存器或内存
传递，字节中的比特 0 包含真值，比特 1~7 必须为零。 ::

    C 语言类型                              返回值位置
    _Bool/char/signed/unsigned              %al，高24位未定义
    short/signed/unsigned                   %ax，高16位未定义
    int/signed/enum/unsigned/long           %eax
    long long/signed/unsigned               %edx:%eax，高32位在 %edx 寄存器中
    any-type */any-type (*)()               %eax
    float/double/long double/__float80      %st(0)
    __float128                              内存
    __Complex float                         %edx:%eax，其中 %edx 是虚数部分，%eax 是实数部分
    __Complex [long] double/__float80/128   内存
    _Decimal32                              %eax
    _Decimal64                              %edx:%eax，高32位在 %edx 寄存器中
    _Decimal128                             内存
    __m64                                   %mm0
    __m128                                  %xmm0
    __m256                                  %ymm0
    __m512                                  %zmm0

没有返回值的函数不会写特别的返回值到任何寄存器。call 指令会将下一条指令的地址压入栈中，
也即被调函数执行完后的返回地址。ret 指令会将返回地址弹出栈并继续执行 call 指令后的下一
条指令。以下是进入被调函数之后，开始以及最后执行的代码，被调函数需要包含上文提到的 5 个
寄存器 %ebp、%ebx、%edi、%esi、%esp，这里还假设分配 80 个字节的额外栈空间来适用； ::

        return address      / 函数调用者压入的继续执行地址
    prologue:
        pushl %ebp          / 保存栈基指针
        movl %esp,%ebp      / 设置当前的栈基指针
        subl $80, %esp      / 分配80字节栈空间
        pushl %edi          / 保护寄存器
        pushl %esi          / 保护寄存器
        pushl %ebx          / 保护寄存器

        movl %edi,%eax      / 寄存器返回值示例
    epilogue:
        popl %ebx           / 恢复寄存器
        popl %esi           / 恢复寄存器
        popl %edi           / 恢复寄存器
        leave               / 恢复栈基指针
        ret                 / 弹出返回地址，跳到返回地址继续执行（即 call 的下一条指令）

虽然一些函数可能被优化不保存和恢复栈基指针，但一般情况还是使用上面标准的开始和结束代码。
位置无关的代码适用 %ebx 寄存器保存全局偏移表的地址。如果一个函数直接或间接需要全局偏移
表的地址，它负责计算这个值。

一些基本类型和所有的复合类型返回值通过使用内存进行返回。返回值如果通过内存返回，函数调用
者负责传递内存返回位置的地址，这个地址通过第一个隐式参数传递给被调函数。让调用者提供返回
对象的空间允许重入。该地址必须满足数据对象的地址对齐要求。被调函数需要将返回值写到给定的
内存地址，并且要负责在返回前将隐式参数从栈中弹出并保存到 %eax 寄存器中。函数调用者可能在
函数返回后获取 %eax 的值来当作返回值的引用。这里的结构体和联合体复合类型是固定大小的，当
前 ABI 没有指定怎样处理变长数据对象。

下面展示了被调函数接受到控制权后（call 指令执行之后），以及调用者重新获得控制权后（ret
指令执行之后）的栈内容： ::

    栈位置      call 指令之后   ret 指令之后    栈位置
    4n+4(%esp)  字长参数n       字长参数n       4n-4(%esp)
                ...             ...
       8(%esp)  字长参数1       字长参数1       0(%esp)
       4(%esp)  内存返回值地址
       0(%esp)  函数返回地址

下面的例子是在上文函数开始和结束代码的基础上，加上对内存返回值地址的处理： ::

        value address       / 内存返回值地址
        return address      / 函数调用者压入的继续执行地址
    prologue:
        popl %eax           / 将函数返回值地址出栈保存到 %eax
        xchgl %eax,0(%esp)  / 将内存返回值地址保存到 %eax，%eax 原本的返回地址保存到栈顶
        pushl %ebp          / 保存栈基指针
        movl %esp,%ebp      / 设置当前的栈基指针
        subl $80, %esp      / 分配80字节栈空间
        pushl %edi          / 保护寄存器
        pushl %esi          / 保护寄存器
        pushl %ebx          / 保护寄存器
        movl %eax,-4(%ebp)  / 将内存返回值地址保存到第一个局部变量中

    epilogue:
        movl -4(%ebp),%eax  / 将内存返回值地址恢复到 %eax 寄存器中
        popl %ebx           / 恢复寄存器
        popl %esi           / 恢复寄存器
        popl %edi           / 恢复寄存器
        leave               / 恢复栈基指针
        ret                 / 弹出返回地址，跳到返回地址继续执行（即 call 的下一条指令）

参数传递和返回值的一个例子： ::

    typedef struct {
        int a, b;
        double d;
    } structparam;
    structparam s;
    int i;
    __m128 v, x, y;
    __m256 w, z;
    extern structparam func(int i, __m128 v, structparam s, __m256 w, __m128 x, __m128 y, __m256 z);
    func(i, v, s, w, x, y, z);

函数参数的寄存器分配： ::

                    函数调用前参数传递位置
    内存返回地址        内存，位于 (%esp)
    i                  内存，位于 4(%esp)
    v                  %xmm0
    s                  内存，位于 8(%esp)
    w                  %ymm1
    x                  %xmm2
    y                  内存，位于 32(%esp)，因为 __m128 需要对齐到16字节边界
    z                  内存，位于 64(%esp)，因为 __m256 需要对齐到32字节边界

栈帧布局： ::

    内容            长度
    z               32个字节
    padding         16个字节
    y               16个字节
    padding         8个字节
    s               16个字节
    i               4个字节
    内存返回地址     4个字节 <--- %esp (对齐到32字节边界)

操作系统接口
============

虚拟地址空间
------------

进程在32位虚拟地址空间中执行，内存管理将虚拟地址转换位物理地址，隐藏物理寻址并允许进程在
系统的真实内存中的任何位置允许。进程通常以三个逻辑段开始，即代码段、数据段、栈。动态链接
器在执行期间可以创建更多的段，进程也可以适用系统服务为自己创建额外的段。

内存通过页面的形式进行组织，这是系统内存分配的最小单位。页面大小可能因系统而异，这取取决
于处理器、内存管理单元、和系统配置。进程可以调用 sysconf(BA_OS) 过程确定系统当前的页面
大小。

在概念上讲，进程拥有全部的32为地址空间。然而在实践中，由几个因素限制了进程的大小：

1. 系统预留了于配置相关的一定量的虚拟空间
2. 系统为每个进程预留了与配置相关的一部分空间
3. 如果一个进程的大小超出了系统可用的，包含了物理内存和辅助存储空间，进行将无法允许；尽
   管运行任何进程都需要一些物理内存空间，但系统可以执行比物理内存大的进程，将它们分页到
   辅助存储中。尽管如此，物理内存和辅助存储空间都是共享资源，只要有系统进程执行负载可用
   的空间就会减少

如下图所示，操作系统预留了虚拟地址空间中高位部分，尽管预留部分和进程空间的边界是由系统配
置的，但预留部分不应该超过1GB空间。因此用户可用虚拟地址空间范围最小上界为 0xc0000000。
具体的操作系统可能预留更少的空间，让更多的用户虚拟空间可用。 ::

             0  | 进程分段 | 内存起始位置
                |   ...   |
    0x80000000  | 动态分段 |
                |   ...   |
                | 系统预留 |
    0xffffffff  |   ...   | 内存结束位置

尽管应用程序可以控制它们的内存布局，但是典型的布局如下： ::

             0  | 栈分段   |
                |   ...   |
    0x08048000  | 代码段   |
                |   ...   |
                | 数据段   |
                |   ...   |
    0x80000000  | 动态分段 |
                |   ...   |

进程的代码段位于 0x08048000，数据段紧随其后，动态分段占据较高的位置。当应用程序让系统为
动态分段（包括共享目标分段）选择地址时，系统会选择高地址。这样就为适用 malloc(BA_OS) 等
工具的动态内存分配留下了中间的地址范围。进程不应依赖于在特定的虚拟地址找到对应的动态分段。
因为存在机制可以让系统选择动态分段的虚拟地址。栈位于代码段的地址以下，向低地址增长。这种
安排为栈提供了略多于 128MB 的空间，为代码和数据提供了大约 2GB 的空间。

下文中的进程初始化部分描述了初始栈内容。栈地址可能在不同的系统不同，甚至在同一系统不同执
行的进程不同。因此，进程不应该依赖于在特定的虚拟地址位置找到对应的栈。一个可调的配置参数
控制着系统栈的最大大小，进程也可以适用 setrlimit(BA_OS) 过程设定自己的最大栈大小，直到
系统限制。在 Intel386 上，栈分段具有读写权限。

操作系统功能，如 mmap(KE_OS) 过程，允许进程以两种方式建立地址映射。首先，程序可以让系统
选择一个地址，其次程序可以让系统使用程序提供的地址。第二种方式可能会引起应用程序的可移植
问题，因为请求的地址可能并不总是可用的。

进程的地址空间通常由三个可以改变大小的段区域，栈（通过 setrlimit(BA_OS)）、数据段（通过
malloc(BA_OS)）、动态段（通过 mmap(KE_OS)）。使用 mmap(KE_OS) 在提供的特定进行映射的
程序可能在某些环境中看似工作正常，在其他环境中却失败。因此，想在其地址空间中创建映像的进
程应该让系统自己选择地址。

尽管提供特定地址的方式需要特别注意，该功能在一些情况下是实用且可控的。例如，多进程应用程
序可能会将多个文件映射到每个进行的地址空间，并在文件数据之间创建相对指针。这可以通过让每
个进程在系统选择的地址请求一定量的内存来完成。在每个进程从系统获得自己的私有地址后，将所
需的文件映射到其中的特定位置。这组映射可能在每个进程中的地址不同，但它们的相对位置是固定
的。如果没有请求特定地址的能力，应用程序就无法构建共享的数据结构，因为在每个进程中文件的
相对位置将是不可预测的。

处理器执行模式
--------------

Intel386 架构有四种执行模式：用户模式（ring 3）和三种特权模式（privileged ring）。用
户进程运行在权限最低的用户模式，而操作系统内核运行在某个特权模式。程序通过 lcall 指令执
行系统调用来改变执行模式，因此 lcall 指令提供了系统调用的低级接口。为确保进程有办法终止
自己，系统提供了 _exit(BA_OS) 过程。包含其他内嵌的 lcall 指令的程序不符合 ABI 标准。 ::

        .globl _exit
    _exit:
        movl $1, %eax
        lcall $7, %0

异常接口
---------

Intel386 架构手册所描述的，处理器会改变模式以处理异常，这些异常可能是同步异常、浮点/协
处理器异常、异步异常。同步和浮点/协处理器异常是能够由进程产生的因指令执行造成的异常。因
此本节特别制定了那些具有定义行为的异常类型。Intel386 架构将异常分类为故障（fault）、陷
阱（trap）、中止（abort）。有关它们的差异参考 Intel386 程序员参考手册。

**硬件异常类型**

操作系统定义了硬件异常与 signal(BA_OS) 指定信号之间的对应关系： ::

    数字    异常名称                信号
    0       除法错误故障            SIGFPE
    1       单步陷阱/故障           SIGTRAP
    2       未掩码中断              无
    3       断点陷阱                SIGTRAP
    4       溢出陷阱                SIGSEGV
    5       边界检查故障            SIGSEGV
    6       非法操作码故障          SIGILL
    7       无协处理器故障          SIGFPE
    8       双精度故障中止          无
    9       协处理器超时中止        SIGSEGV
    10      非法TSS故障             无
    11      分段不存在故障          无
    12      栈异常故障              SIGSEGV
    13      通用包含故障/中止       SIGSEGV
    14      页面故障                SIGSEGV
    15      (预留)                 无
    16      协处理器错误故障        SIGFPE
    其他    (未指定)                SIGILL

架构中存在浮点指令，但它们可以通过硬件（Intel387 芯片）或软件（Intel387 模拟器）实现。
在 “无协处理器” 这种异常情况下，如果 Intel387 模拟器被配置进内核，进程不会收到信号。相
反，系统会截获异常，模拟指令，并将控制权返回给进程。只有当所指的浮点指令非法时（例如无效
的操作数等），进程才会因为 “无协处理器” 异常而接收到 SIGFPE 信号。

**软件陷阱类型**

由于 int 指令生成陷阱（trap），一些硬件异常可以通过软件生成。然而，int 指令只生成陷阱，
而不是故障（fault），因此不可能在软件中精确模拟硬件生成的故障。

进程初始化
-----------

这一部分描述 exec(BA_OS) 为 “婴儿” 进程创建的机器状态，包括参数传递、寄存器使用、栈帧
布局等等。编程语言利用这个初始程序状态为其应用程序建立一个标准环境。例如，一个 C 语言程
序通常在一个名为 main 的函数处开始执行，该函数按以下方式声明。 ::

    extern int main(int argc, char *argv[], char *envp[]);

简单来说，argc 是一个非负的参数计数；argv 是一个参数字符串数组，其中 argv[argc] 的值为
0 表示数组的结束；envp 是一个环境变量字符串数组，同样以空指针终止。尽管这里没有描述 C 程
序的初始化过程，但提供了必要的信息来实现对 main 的调用，或者实现任何其他语言程序的入口点
调用。

**特殊寄存器**

如 Intel386 架构所定义的，几个状态寄存器控制和监控着处理器的状态：机器状态字寄存器（MSW，
Machine Status Word）也称为 %cr0 寄存器，EFLAGS 寄存器、浮点状态寄存器、浮点控制寄存
器。应用程序无法直接访问完整的 EFLAGS 寄存器，因为它们在处理器的用户模式下运行，而且对其
中某些位的写入的指令是需要特权的。尽管如此，程序仍然可以访问 EFLAGS 寄存器中的很多标记。
下面使用星号（*）标记的不能被用户模式进程修改，它们要么具有未指定的值，要么不影响用户程序
的行为。在进行初始化时，EFLAGS 寄存器具有以下所列的值： ::

    标记    描述                值
    CF      进位                未指定（一般为0）
    PF      奇偶位              未指定（一般为0）
    AF      辅助进位            未指定（一般为0）
    ZF      零标志              未指定（一般为0）
    SF      符号位              未指定（一般为0）
    TF      陷阱标志            未指定
    IF*     中断使能            未指定
    DF      方向标志            0（递增、1为递减）
    OF      溢出标志            未指定（一般为0）
    IOPL*   输入输出特权等级    未指定
    NT*     嵌套任务标志        未指定
    RF*     恢复标志            未指定
    VM*     8086虚拟模式        未指定

Intel386 架构定义了浮点指令，无论处理器是否有硬件浮点单元，这些指令都能正常工作（系统可
以提供硬件或软件浮点设施）。因此，MSW 寄存器的内容未指定，允许系统根据硬件配置进行设置。
然而，在任何情况下，处理器都提供了一个工作的浮点实现，包括在进程初始化时具有以下值的浮点
状态和控制寄存器。 ::

    标记    描述                   值
    IC      无穷大表示方式控制位    1 仿射无穷大（为兼容）
    RC      舍入模式控制            00 舍入到最近或偶数
    PC      浮点精度控制            11 53位双精度
    PM      精度异常掩码            1
    UM      下溢异常掩码            1
    OM      上溢异常掩码            1
    ZM      除零异常掩码            1
    DM      非正规操作数异常掩码    1
    IM      非法操作异常掩码        1

浮点的初始状态应该谨慎地修改。特别是，如果精度控制设置少于53位，许多浮点例程可能会产生未
定义的行为。例程 _fpstart 将精度控制更改为64位，并将所有异常设置位默认值。这是符合 C 标
准和 IEEE 754 浮点标准要求的默认状态。

SSE2 的寄存器 MXCSR 中的状态位初始值为： ::

    标记    描述                   值
    FZ      刷入零值                0 不刷零值
    RC      舍入模式控制            0 舍入到最近
    PM      精度异常掩码            1
    UM      下溢异常掩码            1
    OM      上溢异常掩码            1
    ZM      除零异常掩码            1
    DM      非正规操作数异常掩码     1
    IM      非法操作异常掩码        1
    DAZ     非正规操作数为零        0 不是零

**进程栈**

当进程获得控制权后，其栈包含来自 exec(BA_OS) 设置的参数和环境。进程栈的初始内容： ::

    | 未指定                  | 高地址
    | 信息块：包括参数字符串、 |
    |   环境字符串、辅助信息， |
    |   信息块中的内容没有特别 |
    |   的顺序                |
    | 未指定                  |
    | 空辅助向量条目          |
    | 辅助向量条目数组        |
    |   每个条目占两个机器字长 |
    | 全零机器字长            |
    | 环境指针数组            | envp
    | 全零机器字长            |
    | 参数指针数组            | 4(%esp)，argv
    | 参数个数                | 0(%esp)，argc
    | 未指定                  | 低地址

通用和浮点寄存器在进程入口的值是未指定的，除了下面列出的情况除外。因此，需要寄存器具有特
定值的程序必须在进程初始化期间显式设置。它不应该依赖操作系统将所有寄存器设置为 0。

%ebp
    该寄存器的值在进程初始化时是未指定的，但是用户代码应该通过将栈基指针设置为零来表示最
    深的栈帧，其他栈的指针 %ebp 都不应该为零值
%esp
    指向栈的最低地址，即指向有效的栈顶元素，它保证机器字长对齐的（一般在进程入口处保证
    16字节对齐）
%edx
    在符合标准的程序中，该寄存器包含一个函数指针，应用程序应该将其注册到 atexit(BA_OS)
    中，这个函数用于共享库对象的终止，见通用规范中的动态链接部分
%cs %ds %es %ss
    段寄存器被初始化，以便用户进程可以使用32为虚拟地址来访问代码、数据、和栈。程序修改它
    们的值不符合 ABI，将产生未定义行为

数据段和栈段是否最初被映射为拥有可执行权限是未指定的，需要在栈或数据段上执行代码的应用程
序应该采取适当的预防措施，例如调用 mprotect()。新的线程从父线程继承浮点状态，并且在这之
后该状态是线程私有的。

每个进程都有一个栈，但系统没有定义固定的栈地址。此外，程序的栈可能因系统而异，甚至在不同
进程调用之间也可能不同。因此进程初始化代码必须使用 %esp 中的栈地址。虽然参数和环境数据是
从一个应用程序传递到另一个，但辅助向量信息是从操作系统传递到程序的。这个辅助向量是一个数
组，由以下的结构体组成，并根据 a_type 字段的含义进行解释。 ::

    typedef struct {
        int a_type;
        union {
            long a_val;
            void *a_ptr;
            void (*a_fcn)();
        } a_un;
    } auxv_t;

    at_type:
        AT_NULL         0   忽略
        AT_IGNORE       1   忽略
        AT_EXECFD       2   a_val
        AT_PHDR         3   a_ptr
        AT_PHENT        4   a_val
        AT_PHNUM        5   a_val
        AT_PAGESZ       6   a_val
        AT_BASE         7   a_ptr
        AT_FLAGS        8   a_val
        AT_ENTRY        9   a_ptr
        AT_LIBPATH      10  a_val   AT_NOTELF
        AT_FPHW         11  a_val   AT_UID
        AT_INTP_DEVICE  12  a_val   AT_EUID
        AT_INTP_INODE   13  a_val   AT_GID
        AT_EGID         14  a_val
        AT_PLATFORM     15  a_ptr
        AT_HWCAP        16  a_val
        AT_CLKTCK       17  a_val
        AT_SECURE       23  a_val
        AT_BASE_PLATFORM 24 a_ptr
        AT_RANDOM       25  a_ptr
        AT_HWCAP2       26  a_val
        AT_EXECFN       31  a_ptr

AT_NULL
    辅助数组没有固定的长度，使用最后一个元素表示数组的结束，该元素的类型是 AT_NULL
AT_IGNORE
    表示该元素没有意义，对应的 a_un 值没有定义
AT_EXECFD
    在动态链接器部分描述的，exec(BA_OS) 可能会将控制权传递给解释器程序，当这种情况发生
    时，系统会在辅助向量中放置一个 AT_EXECFD 类型或 AT_PHDR 类型的条目。AT_EXECFD 类
    型的条目中的 a_val 成员包含一个文件描述符，该描述符表示的是应用程序可执行文件的描述
    符，解释器可以通过这个描述符读取可执行文件
AT_PHDR
    在某些情况下，系统在将控制权传递给解析器之前会创建应用程序的内存映像。当这种情况发生
    时，AT_PHDR 条目的 a_ptr 成员告诉解释器在哪里可以找到映像中的程序头部表。如果存在
    AT_PHDR 条目，也必须存在 AT_PHENT、AT_PHNUM、AT_ENTRY 类型的条目
AT_PHENT
    其中的 a_val 成员保存程序头部表中每个程序头部的字节大小
AT_PHNUM
    其中的 a_val 成员保存程序头部的个数
AT_PAGESZ
    其中的 a_val 成员给出系统的页面大小（以字节为单位），相同的信息也可以通过 sysconf
    过程获取
AT_BASE
    其中 a_ptr 成员包含了解释器程序被加载到内存的基地址
AT_FLAGS
    如果存在，a_val 包含标志，未定义的位需要设置为零，在 Intel386 架构上暂时还未定义任
    何标志
AT_ENTRY
    其中 a_ptr 成员包含应用程序的入口点，解释器应该将控制权转移至此
AT_LIBPATH
    如果 a_val 成员非零，表示动态链接器在基于通用规范中的共享目标依赖部分的安全考虑来搜
    索进程的共享目标时，应该检查 LD_LIBRARY_PATH 中的目录
AT_FPHW
    其中 a_val 成员的值为 0 表示没有浮点支持，1 表示存在浮点软件模拟，2 表示有 80287
    芯片，3 表示有 80387 或 80487 芯片
AT_INTP_DEVICE
    其中 a_val 成员保存了文件设备号，动态链接器可以从这里加载
AT_INTP_INODE
    其中 a_val 成员保存了文件索引节点（inode），动态链接器可以从这里加载
AT_NOTELF
    其中 a_val 的值如果非零表示该程序的目标文件格式使用的不是 ELF 格式
AT_UID
    进程真实的用户ID
AT_EUID
    进程的有效（effective）用户ID
AT_GID
    进程真实的组ID
AT_EGID
    进程的有效（effective）组ID
AT_PLATFORM
    平台字符串
AT_HWCAP
    CPU 特性的比特掩码，对应的值是由 CPUID 1.EDX 返回的值
AT_CLKTCK
    times() 递增的频率
AT_SECURE
    如果程序处于安全模式（例如用 suid 启动）则该值为 1，否则为 0
AT_BASE_PLATFORM
    基础架构平台字符串
AT_RANDOM
    指向安全生成的16个随机字节
AT_HWCAP2
    扩展的硬件特性掩码，目前它为 0，但未来可能包含额外的特性位
AT_EXECFN
    指向该可执行程序的文件名

假设示例进程接收两个参数 echo、abi，继承了两个环境变量 HOME=/home/dir、PATH=/usr/bin:，
包含一个为空的辅助向量包含一个可执行文件描述符 {AT_EXECFD, 13}，并且栈位于 0x08048000
地址位置，那么该进程的栈布局如下： ::

    |  n  |  :  |  \0 | pad | 高地址
    |  r  |  /  |  b  |  i  |
    |  =  |  /  |  u  |  s  |
    |  P  |  A  |  T  |  H  | 0x08047ff0
    |  d  |  i  |  r  |  \0 |
    |  o  |  m  |  e  |  /  |
    |  E  |  =  |  /  |  h  |
    |  \0 |  H  |  O  |  M  | 0x08047fe0
    |  \0 |  a  |  b  |  i  |
    |  e  |  c  |  h  |  o  |
    |           0           |
    |           0           | 0x08047fd0
    |           13          |
    |           2           | 辅助向量
    |           0           |
    |      0x08047ff0       | 0x08047fc0
    |      0x08047fe1       | envp[]
    |           0           |
    |      0x08047fdd       |
    |      0x08047fd8       | argv[]
    |           2           | 0(%esp), argc
    |         未指定         | 低地址

栈展开算法
-----------

栈帧不是自描述的，当需要进行栈展开时（例如异常处理），需要生成额外的展开信息。这些信息存
储在一个可分配的 .eh_frame 分区中，其格式与 DWARF 调试信息标准定义的 .debug_frame 相
同，但有以下扩展：

1. 位置独立性：为了避免位置无关代码的加载时重定位，FDE CIE 偏移指针应该相对于 CIE 表条
   目的起始位置存储。使用 DWARF 标准此扩展的帧必须将 CIE 标识符标签（identifier tag）
   设置为 1
2. 输出参数区域：为了保持在栈末尾临时分配输出参数区域的大小（当使用 push 指令时），可以
   使用 GNU_ARGS_SIZE（0x2e）操作。此操作采用一个 uleb128（无符号小端128位）参数来指
   定当前的大小。这些信息用于在展开栈帧后跳转到函数的异常处理程序时调整栈帧。另外 CIE
   Augmentation 应包含所使用编码的确切规范。推荐尽可能使用 PC 相对编码，并根据所使用的
   代码模型调整大小
3. CIE 增强（Augmentation）：增强字段的格式是依据存储在 CIE 头部中的增强格式字符串决定
   的，该字符串包含以下字符：z 表示存在一个 uleb128 用于确定增强部分的大小；L 表示 FDE
   增强 LSDA 指针的编码（以及是否存在），数据字段由单字节组成，指定了指针的编码方式，其
   值是下表指定值的掩码，默认的 DWARF 指针编码（直接4字节绝对指针）由值 0 表示；R 表示
   FDE 代码指针的非默认指针编码，格式由单字节表示，与 L 命令中的格式相同；P 表示 CIE 增
   强存在语言个性化例程以及编码，编码由单字节表示，与 L 命令中的格式相同，随后是按照指定
   编码的个性化的函数指针。但存在增强时，第一个命令必须时 z，方便轻松跳过信息

指针编码规范字节的含义： ::

    0x01    值以 uleb128 类型或 sleb128 类型存储（根据 0x08 标志位）
    0x02    值以2字节整数存储（udata2 或 sdata2）
    0x03    值以4字节整数存储（udata4 或 sdata4）
    0x04    值以8字节整数存储（udata8 或 sdata8）
    0x08    有符号数
    0x10    值是 PC 相对的
    0x20    值是代码段相对的
    0x30    值是数据段相对的
    0x40    值是函数起始位置相对的

其中 CIE（Common Information Entry）公共信息入口，包含了许多用于栈展开的通用信息。FDE
（Frame Description Entry）帧描述入口，为每个函数提供了具体的栈展开信息，如函数的起始
地址，栈大小，如果恢复寄存器值等。LSDA（Language Specific Data Area）特定语言数据区，
用于 C++ 等语言的异常处理，提供关于异常处理器的位置信息。

在 DWARF 调试信息中，位置独立性和输出参数区域的维护是为了确保当程序被加载到内存中的任意
位置时，调试信息仍然有效，并且异常处理可以正确地识别和调整栈帧。这些特性对于生成在不同内
存地址运行共享库和可执行文件至关重要。

为了简化展开表的操作，运行时库提供了更高级别的 API 用于栈展开机制： ::

    _Unwind_RaiseException
    _Unwind_Resume
    _Unwind_DeleteException
    _Unwind_GetGR
    _Unwind_SetGR
    _Unwind_GetIP
    _Unwind_SetIP
    _Unwind_GetRegionStart
    _Unwind_GetLanguageSpecificData
    _Unwind_ForcedUnwind
    _Unwind_GetCFA

DWARF（Debug With Arbitrary Record Format）是为符号级、源代码级调试
而开发的规范，这种调试信息格式并不偏袒任何编译器或调试器的设计。相关 DWARF 的更多信息，
可参阅 DWARF 调式信息格式标准（https://dwarfstd.org/）。下表是 DWARF 关于 Intel386
处理器的寄存器号映射： ::

    寄存器              序号    表示
    EAX                 0       %eax
    ECX                 1       %ecx
    EDX                 2       %edx
    EBX                 3       %ebx
    ESP                 4       %esp
    EBP                 5       %ebp
    ESI                 6       %esi
    EDI                 7       %edi
    函数返回地址 RA      8       返回地址不在寄存器中，而位于内存栈 0(%esp) 位置
    标志寄存器           9       %EFLAGS
    预留                10      预留
    浮点寄存器 0–7      11-18    %st0–%st7
    预留                19-20   预留
    向量寄存器 0–7      21-28   %xmm0–%xmm7
    MMX 寄存器 0–7      29-36   %mm0–%mm7
    SSE2 控制状态寄存器 39      %mxcsr（Media Control and Status）
    段寄存器 ES         40      %es
    段寄存器 CS         41      %cs
    段寄存器 SS         42      %ss
    段寄存器 DS         43      %ds
    段寄存器 FS         44      %fs
    段寄存器 GS         45      %gs
    预留                46-47   预留
    任务寄存器          48      %tr
    LDT 寄存器          49      %ldtr
    预留                50-92   预留
    FS 基地址           93      %fs.base
    GS 基地址           94      %gs.base

代码示例
=========

这部分内容是基本操作的代码示例，例如函数调用、访问静态对象、将控制权从一个程序部分转移到
另一个部分。上文种讨论了程序如果使用机器或操作系统，以及对执行环境可假设和不可假设的明确
规定。而这里的内容不同，只说明了操作可能的执行方式，而不是必须的执行方式。示例使用 C 语
言，其他编程语言可能使用下面展示的相同约定，但不这样做并不妨碍程序符号 ABI。有两个主要的
目标代码模型可用：

1. 绝对代码；在此模型下，指令包含绝对地址，为了正确执行，程序必须在特定的虚拟地址加载，
   使得程序得绝对地址与进程得虚拟地址一致
2. 位置无关代码：在此模型下，指令包含相对地址，而不是绝对地址。因此，代码不依赖于特定的
   加载地址，允许它在虚拟内存中的不同位置正确执行

接下来的部分描述这两个模型间的区别，当模型不同时，代码会一起出现以便于比较。下文的例子展
示的是带有各种简化的代码片段，它们旨在解释寻址模式，而不是展示最优的代码，也不是为了复制
编译器的输出。当该文档的其他章节展示汇编语言代码时，它们通常只展示绝对地址版本，而这一章
节中的信息解释了位置无关代码将如何修改这些示例。

代码模型
---------

当系统创建进程映像时，进程的可执行文件部分具有固定地址，系统选择共享目标库的虚拟地址以避
免与进程中的其他段发生冲突。未来最大化代码共享，共享目标通常使用位置无关代码，其中指令不
包含绝对地址。共享目标文件中的代码段可以在不同的虚拟地址加载而无需更改段映像。因此，即使
每个进程中的段位于不同的虚拟地址，多个进程也可以共享单个共享目标的代码段。

位置无关代码依赖于两种技术：

1. 控制转移指令持有相对于指令指针（EIP）的偏移，EIP 相对的分支或函数调用根据当前指令指
   针计算其目标地址，而不是相对任何绝对地址
2. 当程序需要绝对地址时，它计算所需的值。编译器在执行期间生成代码以计算绝对地址，而不是
   在指令中嵌入绝对地址

由于 Intel386 架构提供了 EIP 相对的调用和分支指令，编译器可以轻松满足第一个条件。全局
偏移表则提供地址计算信息，位置无关目标文件（可执行和共享目标文件）在其数据段中维护该表。
当系统为目标文件创建内存映像时，表条目被重定位以反映为单个进程分配的绝对虚拟地址。由于数
据段对于每个进程是私有的，因而与多个进程共享的代码段不同，可以修改全局偏移表中的内容。

下面的汇编代码展示了位置无关代码所需的显式表示：

``name@GOT(%ebx)``
    这个表达式表示的是符号 name 重定位后的真实地址，其中 ``name@GOT`` 表示的是符号对应
    的全局偏移表条目相对全局偏移表的偏移，而 %ebx 保存的是全局偏移表的绝对地址，因此该
    表达式实际上就是读取符号对应条目中的内容，而该条目内容保存的就是符号的真实地址
``name@GOTOFF(%ebx)``
    这个表达式读取的是符号 name 的值，其中 ``name@GOTOFF`` 表示这个符号相对于全局符号
    表的偏移，因此 ``name@GOTOFF + %ebx`` 是这个符号的绝对地址，因此该表达式读取这个绝
    对地址中的内容，即该符号的值。因此这个表达式引用的是符号本身，不是符号对应的全局偏移
    表条目
``name@PLT``
    这个表达式表示对符号的过程链接表条目的 EIP 相对引用
``_GLOBAL_OFFSET_TABLE_``
    该符号用于访问全局偏移表，当指令使用该符号时，它看到的是当前指令和全局偏移表之间的偏
    移量作为符号的值

位置无关函数起始代码
---------------------

函数的起始代码为局部栈空间分配内存，保存它必须保护的寄存器，并将寄存器 %ebx 设置为全局
偏移表的地址。因为 %ebx 对每个函数是私有的，并且在函数调用之间进行了保护，只需要在函数
入口处计算它的值一次。下面是计算全局编译表绝对地址的代码： ::

            call .L1
    .L1:    popl %ebx
            addl $_GLOBAL_OFFSET_TABLE_+[. - .L1], %ebx

其中 call 指令将下一条指令的绝对地址压入栈中；接着 popl 指令将栈中的绝对地址弹出栈保存
到 %ebx 寄存器中；最后一条指令计算所需的绝对地址保存到 %ebx 中，这里的 _GLOBAL_OFFSET_TABLE_
给出了从 addl 指令到全局偏移表的偏移，而 [. - .L1] 表示从 .L1 到 addl 指令的偏移，将
两个偏移相加，得到 .L1 到全局编译表的偏移，而 .L1 的绝对地址保存在 %ebx 中，因此全局偏
移表的地址就是这个偏移加上 .L1 的绝对地址。

这个计算可以添加到标准的函数起始代码中，用于位置无关代码的标准起始代码。下面的起始代码假
设分配80个字节的局部栈空间，并保护了本地的私有寄存器 %ebx、%esi、%edi: ::

    prologue:
            pushl   %ebp
            movl    %esp, %ebp
            subl    $80, %esp
            pushl   %edi
            pushl   %esi
            pushl   %ebx
            call    .L1
    .L1:    popl    %ebx
            addl    $_GLOBAL_OFFSET_TABLE_+[. - .L1], %ebx

位置无关代码和绝对地址代码都可以使用这个相同的起始代码。根据该地址计算，可以知道整个代码
段必须在全局偏移表之前，而全局变量和函数（包括外部和静态全局变量和函数）的地址，都必须在
全局偏移表之后。

数据对象
--------

这里不讨论栈上的数据对象，因为程序总是相对于栈基指针计算它们的虚拟地址。这里描述的是具有
静态存储生命期的数据对象。在 Intel386 架构中，所有的内存引用指令都可以访问32位地址空间
内的任何位置。绝对代码中的符号引用将符号的值或绝对虚拟地址放入指令中。这意味在编写绝对地
址代码时，编译器会直接将静态对象的地址编码到指令中。这种方法的一个限制是，如果程序被加载
到一个不同的虚拟地址，这些硬编码的地址将不再有效。因此，绝对代码不适合需要在不同加载地址
运行的共享库或可执行文件。以下是使用绝对地址的代码： ::

    extern int src;     .globl src, dst, ptr
    extern int dst;
    extern int *ptr;
    ptr = &dst;         movl $dst, ptr
    *ptr = src;         movl ptr, %eax      / ptr 符号的地址
                        movl src, %edx      / src 符号的地址
                        movl (%edx), %edx   / 读取符号 src 的内容
                        movl %edx, (%eax)   / 将 src 的内容保存到 ptr 指向的地址

位置无关指令不能包含绝对地址，相反引用符号的指令持有符号在全局编译表中的编译量。将偏移与
%ebx 中的全局编译表的地址结合，可以得到对应表条目的绝对地址，而表条目中包含的就是所需的
地址。以下是使用位置无关指令的代码： ::

    extern int src;     .globl src, dst, ptr
    extern int dst;
    extern int *ptr;
    ptr = &dst;         movl ptr@GOT(%ebx), %eax    / ptr 符号的真实地址
                        movl dst@GOT(%ebx), %edx    / dst 符号的真实地址
                        movl %edx, (%eax)
    *ptr = src;         movl ptr@GOT(%ebx), %eax    / ptr 符号的地址
                        movl (%eax), %eax           / 读取符号 ptr 的值，是一个地址
                        movl src@GOT(%ebx), %edx    / src 符号的地址
                        movl (%edx), %edx           / 读取符号 src 的值
                        movl %edx, (%eax)

上面的代码都是全局变量，而对于局部使用的静态变量可以进行优化。因为全局变量可能引用的是一
个不在当前目标文件中的外部符号，也即全局符号可能需要通过动态链接将其绑定到一个外部共享库
中的定义，它必须使用全局偏移表中的条目。而局部使用的静态变量，一定是位于当前的可执行文件
或共享目标文件内部的一个位置。可以使用 ``name@GOTOFF`` 来获得该符号相对于全局偏移表的偏
移，从而直接获取符号的值。下面是局部静态变量位置无关代码的例子： ::

    static int src;
    static int dst;
    static int *ptr;
    ptr = &dst;         leal ptr@GOTOFF(%ebx), %eax
                        leal dst@GOTOFF(%ebx), %edx
                        movl %edx, (%eax)
    *ptr = src;         movl ptr@GOTOFF(%ebx), %eax / 读取符号 ptr 的值，是一个地址
                        movl src@GOTOFF(%ebx), %edx / 读取符号 src 的值
                        movl %edx, (%eax)           / 将值保存到地址对应的内存中

函数调用
--------

程序使用 call 指令来进行直接函数调用，call 指令的目标是一个 EIP 相对值，可以用来访问32
位虚拟空间中的任何地址。即使函数的代码位于共享库中，调用者也可以使用相同的汇编代码。尽管
在这种情况下，控制权从原始调用通过间接的代码序列传递到目标位置。有关间接代码序列，可参见
后文的过程链接表部分。

动态链接可能会将函数调用重定位到当前目标对象文件的范围之外，因此位置无关的调用应该显式地
使用过程链接表。PLT 是一个特殊的跳转表，它允许在运行时解析目标地址，从而支持动态链接。当
程序首次调用一个函数时，控制权会转移到 PLT 中的一个存根（stub），该存根会将控制权转发到
动态链接器，然后链接器将解析函数的实际地址，并可能更新 PLT 项目已直接指向函数的已解析地
址，以便后续调用可以直接跳转到该函数。这种方式确保了代码的位置无关，因为函数调用不依赖于
函数代码的绝对位置，而是依赖于相对于程序计数器（EIP）的编译量，以及 PLT 提供的间接层。这
样，即使代码被加载到内存中的不同位置，函数调用仍然可以正确的解析目标地址。

以下时函数直接调用的代码： ::

    extern void function();
    function();

    绝对地址直接调用：
    .globl function
    call function

    位置无关的直接调用：
    .globl function
    call function@PLT

间接函数调用使用间接 call 指令。对于位置无关代码，全局偏移表提供了所有所需符号的绝对地址，
不管是数据对象还是函数。以下是间接函数调用的绝对地址代码： ::

    extern void (*ptr)();       .globl ptr, name;
    extern void name();
    ptr = name;                 movl $name, ptr
    (*ptr)();                   call *ptr

以下是间接函数调用的位置无关代码： ::

    extern void (*ptr)();       .globl ptr, name;
    extern void name();
    ptr = name;                 movl ptr@GOT(%ebx), %eax    / ptr 符号的真实地址
                                movl name@GOT(%ebx), %edx   / name 符号的真实地址
                                movl %edx, %(eax)
    (*ptr)();                   movl ptr@GOT(%ebx), %eax    / ptr 符号的真实地址
                                call *(%eax)

分支跳转
--------

程序使用分支指令来控制其执行流程，如 Intel386 架构定义的，分支指令持有一个 EIP 相对值，
具有有符号的32位值范围，允许跳转到虚拟地址空间内的任何位置。例如： ::

    label:                  .L01:
        ...                     ...
        goto label;             jmp .L01

C 语言的 switch 语句提供了多路选择，当 switch 语句的 case 标签满足条件时，编译器用地址
表来实现选择。以下示例使用几种简化的惯例用法来隐藏不相关的细节：

1. 选择表达式位于 %eax 寄存器中
2. case 标签常量从零开始
3. case 标签、default、地址表分别使用汇编名称 .Lcasei、.Ldef、.Ltab

绝对代码的地址表条目包含虚拟地址，选择代码提取条目的值并跳转到该地址。位置无关的表条目持
有编译量，选择代码计算目的地址的绝对地址。以下是使用绝对地址的 switch 代码： ::

    switch (j) {                cmpl    $3, %eax
    case 0:                     ja      .Ldef
        ...                     jmp     *.Ltab(,%eax,4)
    case 2:             .Ltab:  .long   .Lcase0
        ...                     .long   .Ldef
    case 3:                     .long   .Lcase2
        ...                     .long   .Lcase3
    default:
        ...
    }

以下是位置无关的 switch 代码： ::

            cmpl    $3, %eax
            ja      .Ldef
            leal    .Ltab@GOTOFF(%ebx), %edx
            movl    (%edx,%eax,4), %eax
            movl    .Ltab@GOTOFF(%ebx,%eax,4), %eax
            call    .Ljmp
    .Ljmp:
            popl    %ecx
            addl    %ecx, %eax
            jmp     *%eax
    .Ltab:
            .long   .Lcase0 - .Ljmp
            .long   .Ldef - .Ljmp
            .long   .Lcase2 - .Ljmp
            .long   .Lcase3 - .Ljmp

C 栈帧
-------

下图展示了 C 栈帧的组织结构： ::


    位置            内容          栈帧
    4n+4(%ebp)      字长参数n    _______ 高地址栈底
                    ...          前一帧
       8(%ebp)      字长参数1    _______
       4(%ebp)      返回地址
       0(%ebp)      原%ebp (O)
      -4(%ebp)      局部空间      当前帧
                    自动变量
                    临时变量
      -4x(%ebp)     等...
        8(%esp)     原%edi
        4(%esp)     原%esi
        0(%esp)     原%ebx      _______ 低地址栈顶

一个 C 栈帧在执行期间通常不会改变大小，除了下文将要讨论的动态分配的栈内存。按照惯例，函
数在其帧的中间分配局部变量，并将它们作为 %ebp 的负偏移引用。而函数的传入参数位于前一帧，
作为 %ebp 的正偏移量引用。如果需要，函数会按照上图所示的位置保护 %edi、%esi、%ebx 的值，
并在返回调用者之前恢复它们的值。

目标文件
=========

文件头部
---------

文件标识信息字段 e_ident，Intel386 架构要求的值如下： ::

    字段                值
    e_ident[EI_CLASS]   ELFCLASS32      32位机器数据类型
    e_ident[EI_DATA]    ELFDATA2LSB     二进制补码小端字节序

处理器信息字段 e_machine 的值必须是 EM_386；处理器标记 e_flags 由于 Intel386 没有定
义标记，该值为零。


特殊分区
---------

各种不同的分区包含有程序和控制信息，下面列出的是系统使用的分区： ::

    分区名称         分区类型            分区属性
    .got            SHT_PROGBITS        SHF_ALLOC|WRITE
    .plt            SHT_PROGBITS        SHF_ALLOC|EXECINSTR

.got
    该分区包含全局偏移表

.plt
    该分区包含过程链接表


符号表分区
-----------

如果一个可执行文件引用了一个定义在共享目标文件中的函数，符号表中会包含这个引用符号。其中
的 st_shndx 字段的值为 SHN_UNDEF，表示这个符号没有定义在这个可执行文件中。如果这个符号
在过程链接表中分配了一个条目，并且 st_value 字段的值不是零，那么这个值是过程链接表对应
条目第一条指令的虚拟地址。否则 st_value 字段的值为零。这个过程链接表条目的地址，被动态
链接器用来解析函数地址引用。

重定位类型
-----------

重定位结构体字段 r_offset 指定了受影响存储单元第一个字节的文件偏移或虚拟地址。Intel386
架构只是用 Elf32_Rel 这个重定位结构体，附加值保存在被重定位字段中。

重定位结构体中的重定位类型指定了怎样修改以下的数据字段：

    word32

该数据字段的值，是在链接编辑器将一个或多个重定位文件合并到一个可执行文件或共享目标文件的
过程中计算的。概念上，链接器首先决定怎样合并和定位这些输入文件，然后更新符号的值，最后执
行重定位。应用到可执行文件或共享目标文件的重定位是类似的，都产生相同的结果。

Intel386 定义的重定位类型如下。其中 A 表示附加值；B 表示基地址，共享目标文件的基地址是
零，可执行文件的基地址则不同；G 表示相对全局偏移表的偏移，其中保存的是重定位符号最终执行
的地址；GOT 表示全局偏移表的地址；L 表示重定位符号的过程链接表条目的偏移或地址，过程链接
表条目将一个函数调用重定位到合适的目标，链接编辑器会创建一个初始的过程链接表，然后动态链
接器会在执行过程中修改它；P 表示使用 r_offset 计算的被重定位后的存储单元的偏移或地址；
而 S 是重定位符号的值。 ::

                            数据字段    计算方式
    R_386_NONE      0       无          无
    R_386_32        1       word32      S + A
    R_386_PC32      2       word32      S + A - P
    R_386_GOT32     3       word32      G + A - P
    R_386_PLT32     4       word32      L + A - P
    R_386_COPY      5       无          无
    R_386_GLOB_DAT  6       word32      S
    R_386_JMP_SLOT  7       word32      S
    R_386_RELATIVE  8       word32      B + A
    R_386_GOTOFF    9       word32      S + A - GOT
    R_386_GOTPC     10      word32      GOT + A - P

下面这些重定位类型有除以上计算方式之外的含义：

R_386_GOT32
    计算的是符号的全局偏移表条目相对全局偏移表的偏移，可以辅助链接编辑器创建全局偏移表
R_386_PLT32
    计算的是符号的过程链接表条目的地址，用来辅助链接编辑器创建过程链接表
R_386_COPY
    链接编辑器创建这种重定位类型用于动态链接，其中的 r_offset 字段指向的是一个可写字段
    位置。重定位符号必须存在于当前的目标文件以及共享目标文件中，在执行时，动态链接器会拷
    贝共享目标文件中的符号到 r_offset 指定的字段中
R_386_GLOB_DAT
    该重定位类型用于将符号的地址设置到全局偏移表条目中
R_386_JMP_SLOT
    链接编辑器创建这种重定位类型用于动态链接，其中的 r_offset 字段是过程链接表条目的地
    址。动态链接器修改过程链接表条目从而将控制权转移到符号的地址
R_386_RELATIVE
    链接编辑器创建这种重定位类型用于动态链接，其中的 r_offset 字段是共享目标文件中的一
    个位置。动态链接器会基于共享目标文件所在的虚拟地址来计算符号的虚拟地址。该类型的重定
    位结构体中的符号索引必须设置为 0
R_386_GOTOFF
    计算的是符号值与全局编译表的偏移，用来辅助链接编辑器创建全局偏移表
R_386_GOTPC
    该重定位类型类似于 R_386_PC32，唯一不同的是使用全局偏移表的地址进行计算。该类型的重
    定位符号一般是 _GLOBAL_OFFSET_TABLE_，它用来辅助链接编辑器创建全局偏移表

程序加载
=========

当系统创建程序映像时，逻辑上是将一个文件的分段拷贝到一个虚拟内存分段。但是系统什么时候以
及是否物理地读取文件，依赖于程序的执行行为。进程在真正引用对应的逻辑页之前不需要分配一个
物理页，而且进程通常会留下很多未引用的页。因此延迟物理读取可以提升系统性能，为了在实践中
获得这种效率，可执行文件和共享目标文件中的分段映像的文件偏移或虚拟地址必须同余到内存页面
大小，即它们除以页大小之后的余数相同。

Intel386 最大的页面大小是 4KB（0x1000），因此分段必须同余到 4KB 或更大的2的幂。下面是
一个可执行文件分段的例子： ::

    文件偏移      文件内容       虚拟地址
          0     ELF 文件头部
                程序头部表
                其他头部信息
      0x100     代码段...       0x8048100
                0x2be00字节     0x8073eff
    0x2bf00     数据段...       0x8074f00
                0x4e00字节      0x8079cff
    0x30d00     其他信息

该可执行文件包含了一个代码段和一个数据段，根据上面的内容程序头部表中需要包含： ::

    程序头部结构体   代码段       数据段
        p_type      PT_LOAD     PT_LOAD
        p_offset    0x100       0x2bf00
        p_vaddr     0x8048100   0x8074f00
        p_paddr     0           0
        p_filesz    0x2be00     0x4e00
        p_memsz     0x2be00     0x5e24
        p_flags     PF_R|PF_X   PF_R|PF_W|PF_X
        p_align     0x1000      0x1000

加载后的进程映像段： ::

        虚拟地址     代码段
        0x8048000   头部填补
                    0x100字节
        0x8048100   代码段内容
                    0x2be00字节
        0x8073f00   数据填补
                    0x100字节

                    数据段
        0x8074000   代码填补
                    0xf00字节
        0x8074f00   数据段内容
                    0x4e00字节
        0x8079d00   未初始化数据
                    0x1024字节（全零）
        0x807ad24   页面填补
                    0x2dc字节（全零）

加载共享目标文件与加载可执行文件的一点不同是，共享目标文件段包含的是位置无关的代码，使得
分段的虚拟地址随着实际进程的不同而变化。尽管系统为每个进程单独选择虚拟地址，但是还是会维
护与分段的相对位置关系。因为位置无关代码在分段之间使用相对地址，内存虚拟地址页必须匹配这
种相对关系。下表示意了多个进程虚拟地址固定的相对位置关系，以及基地址的计算。 ::

                    文本段        数据段           基地址
    共享目标文件      0x200         0x2a400            0x00
    进程1       0x80000200      0x8002a400      0x80000000
    进程2       0x80081200      0x800ab400      0x80081000
    进程3       0x900c0200      0x900ea400      0x900c0000
    进程4       0x800c6200      0x900f0400      0x900c6000


动态链接
=========

程序解释器
-----------

满足 Intel386 ABI 规范的程序解释器： ::

    /usr/lib/libc.so.1

动态链接段
-----------

动态链接段的内容由动态链接结构体组成，这些内容为动态链接器提供信息。这些信息有些是处理器
相关的，包含结构体里面一些字段的解释。其中标签 DT_PLTGOT 表示该结构体保存的时过程链接表
或全局偏移表的地址。在 Intel386 架构上，该结构体的 d_ptr 字段给出的是全局偏移表的地址，
在后面可以看到，全局偏移表中前三个条目是预留的，其中的两个用来保存过程链接表的信息。

全局偏移表
-----------

总体上，位置无关的代码不能包含绝对虚拟地址。而全局偏移表保存的绝对地址是私有数据，因此使
得这些地址也不违背位置无关以及程序代码的共享要求。程序使用位置无关的地址来引用全局偏移表，
然后获得对应地址的绝对值，这样可以将位置无关的引用重定向到绝对位置。

初始状态下，全局偏移表保存着重定位条目所需的信息。当系统为可加载对象文件创建内存分段后，
动态链接器处理重定位条目，这其中有一些是引用全局偏移表的 R_386_GLOB_DAT 重定位类型。动
态链接器确定关联的符号的值，并计算符号的绝对地址，并设置到全局偏移表中。尽管绝对地址在链
接编辑器创建目标文件时时未知的，动态链接器知道所有内存分段的地址，因而可以计算出符号的绝
对地址。

如果程序需要直接访问符号的绝对地址，这个符号就需要一个全局偏移表条目。因为可执行文件和共
享目标文件的全局偏移表是分离的，一个符号的地址可能出现在多个表中。动态链接器会在将控制权
交给程序映像之前处理所有的全局偏移表重定位，因而绝对地址在执行时可用。

全局偏移表的第一个条目用来保存动态结构体数组的地址，即符号 _DYNAMIC 引用的数组。在 Intel386
架构上，第二个和第三个条目也是保留的，见下面的过程链接表部分。

系统可以给相同的共享目标选择不同的内存分段地址，甚至会为同一个程序的不同执行选择不同的库
地址。但不管怎样，内存分段在程序映像构建好之后就不会再改变。在进程退出之前，进程的内存分
段都位于固定的虚拟地址上。

一个全局偏移表的格式以及如何解析式处理器相关的，对于 Intel386 架构，以下这个符号可以用
来访问全局偏移表： ::

    extern Elf32_Addr _GLOBAL_OFFSET_TABLE_[];

这个符号可能位于 .got 分区的中间，允许基于这个数组地址的负数或非负数索引访问。

函数地址
---------

在可执行文件和共享目标文件中引用一个函数的地址，可能不会解析到同一个值。在共享目标对象中，
动态链接器通常解析到该函数自己的虚拟地址上。而可执行文件中引用一个共享目标文件中的函数，
通常被链接编辑器解析到过程链接表条目的地址。

为了使函数地址的比较能正常工作，如果可执行文件引用了一个共享目标文件中的函数，链接编辑器
会将该函数对应的过程链接表条目的地址写入到函数符号中。动态链接器会特殊对待这种符号，当链
接编辑器搜索到该符号时，通常会按以下规则处理：

1. 如果符号的 st_shndx 字段不是 SHN_UNDEF，表示找到了该符号的定义，则使用 st_value 的
   值作为符号的地址
2. 如果 st_shndx 的值是 SHN_UNDEF，并且符号的类型是 STT_FUNC，st_value 的值不是 0，
   那么也是用 st_value 的值作为符号的地址
3. 否则，动态链接器认为这个符号在这个可执行文件中是未定义的，将继续处理

一个重定位被关联到链接过程表的条目中，这些条目用来直接函数调用而不是引用函数地址。这些重
定位不会按上面的规则特殊对待，因为动态链接器禁止将过程链接表条目重定向到它们自己身上。

过程链接表
-----------

类似于全局偏移表将位置无关的地址重定向到绝对地址，过程链接表将位置无关的函数调用重定向到
绝对地址。链接编辑器不能解决一个可执行目标到另一个的执行转移（例如函数调用），它只能将程
序的转移控制放到过程链接表条目中。

在 Intel386 架构中，过程链接表位于共享代码中，但是使用私有的全局偏移表中的地址。动态链
接器会确定目标的绝对地址并且据此修改全局偏移表的内存映像。从而可以重定向条目而不违反程序
代码的位置无关和共享。可执行文件和共享目标文件有各自的过程链接表。

绝对过程链接表： ::

    .PLT0: pushl got_plus_4
           jmp *got_plus_8
           nop; nop
           nop; nop
    .PLT1: jmp *name1_in_GOT
           pushl $offset
           jmp .PLT0@PC
    .PLT2: jmp *name2_in_GOT
           pushl $offset
           jmp .PLT0@PC
           ...

位置无关的过程链接表： ::

    .PLT0: pushl 4(%ebx)
           jmp *8(%ebx)
           nop; nop
           nop; nop
    .PLT1: jmp *name1@GOT(%ebx)
           pushl $offset
           jmp .PLT0@PC
    .PLT2: jmp *name2@GOT(%ebx)
           pushl $offset
           jmp .PLT0@PC
           ...

根据一些步骤，动态链接器和程序一起使用过程链接表和全局偏移表来解决符号引用：

1. 当第一次创建程序的内存映像时，动态链接器将全局便宜表的第二个和第三个条目设置为特殊值
2. 如果过程链接表时位置无关的，全局偏移表的地址必须位于 %ebx 寄存器中。每个进程映像中的
   共享目标文件都有自己的过程链接表，到一个过程链接表条目的控制转移只能发生在相同目标文
   件内部。因此，主调函数需要负责在调用过程链接表条目之前设置全局偏移表的基寄存器
3. 假如有一个名为 name1 的程序，它将控制权转移到标签 .PLT1
4. 第一条指令跳转到 name1 对应的全局偏移表条目的地址，初始化时全局偏移表保存的是下面的
   pushl 指令的地址，而不是 name1 的真正地址
5. 因此，程序将重定位偏移（offset）入栈，重定位偏移是一个32位的基于重定位表的字节偏移。
   对应的重定位类型是 R_386_JMP_SLOT，并且其中偏移字段的值就是对应的全局偏移表条目的偏
   移。重定位条目还包含符号索引，告诉动态链接器是哪个符号被引用，这里是 name1
6. 然后程序会跳转到 .PLT0，即过程链接表的第一个条目。pushl 指令会将第二个全局偏移表条目
   的值入栈，然后程序跳转到全局偏移表的第三个条目的地址，这时会将控制权交给动态链接器
7. 动态链接器接收到控制权后，它会展开栈，查看重定位条目，找到符号的值，将 name1 真实的
   地址保存到对应的全局偏移表条目中，并且将控制权转移给要求的目标

环境变量 LD_BIND_NOW 可以改变动态链接的值，如果这个值不为空，动态链接器会在将控制权交给
前程之前对过程链接表求值。也就是，动态链接器会在进程初始化时处理类型为 R_386_JMP_SLOT
的重定位条目。否则，动态链接器会延迟对过程链接表求值，会将符号解析和重定位推迟到过程链接
表条目的第一次执行。

延迟绑定会提高总体应用程序性能，因为未使用的符号不会引起额外的动态链接开销。然而，两种情
况使延迟绑定时对一些应用程序是不可接受的。第一种情况，因为动态链接器会拦截函数的调用来解
析对应的函数符号，一些应用程序受不了这种开销。第二种情况是，如果动态链接器找不到对应的符
号会终止程序，而在延迟绑定情况下，这种错误情况的发生是任意的，一些应用程序不能容忍这种不
确定性。通过关闭延迟绑定，动态链接器会在将控制权交给应用程序之前处理进程初始化时就强制报
出所有发生的错误。
