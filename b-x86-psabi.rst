x86 补充规范

* `底层机器接口`_

  * `处理器架构`_
  * `数据表示`_
  * `位域`_

* `函数调用约定`_

  * `寄存器`_
  * `栈帧`_
  * `传参`_
  * `可变参数传递`_
  * `返回值`_

* `操作系统接口`_

  * `虚拟地址空间`_
  * `处理器执行模式`_
  * `异常接口`_
  * `进程初始化`_

* `目标文件`_

  * `文件头部`_
  * `特殊分区`_
  * `符号表分区`_
  * `重定位类型`_

* `程序加载`_

* `动态链接`_

  * `程序解释器`_
  * `动态链接段`_
  * `全局偏移表`_
  * `函数地址`_
  * `过程链接表`_

底层机器接口
=============

处理器架构
----------

Intel 80386 程序员参考手册（Intel 文献序号 230985）和 Intel 80387 程序员参考手册（Intel
文献序号 231917）共同定义了处理器架构。组合的 Intel386/Intel387 处理器架构此后被称为
Intel386 架构。直接在该处理器上执行的程序意味着使用该架构的指令集、指令编码和指令语义。
有三点需要明确指出的是：

1. 一个程序可以假定所有记录在文档中的指令都是存在的
2. 一个程序可以假定所有记录在文档中的指令都是工作的
3. 一个程序只可以使用由架构定义的指令

换句话说，从程序的角度来看，执行环境提供了一个完整且正常工作的 Intel386 架构实现。这并
不意味着底层实现以硬件形式提供了所有指令，只是这些指令执行了指定的操作并产生了指定的结果。
ABI（应用程序二进制接口）既不对系统的执行性能施加限制，也没有指定必须以硬件形式实现哪些
指令。符合 ABI 的架构软件仿真是可能的。

一些处理器可能作仅支持 Intel386 架构的一个子集，或者提供额外的指令或功能。显式使用这些
功能的程序不符合 Intel386 ABI。在没有支持这些额外功能的机器上执行这种程序将导致未定义的
行为。

数据表示
---------

本规范中，halfword 表示的是16位大小的对象，word 表示32位大小的对象，doubleword 表示64
位大小的对象。或者可以使用 twobyte、fourbyte、eightbyte 表示。以下是 C 语言中的基本类
型与处理器类型的对应关系和信息： ::

    C 语言类型                                      大小和对齐  Intel386
    _Bool                                           1   1       boolean
    char/signed char/unsigned char                  1   1       byte
    short/signed short/unsigned short               2   2       twobyte (halfword)
    int/signed int/enum/unsigned int                4   4       fourbyte (word)
    long/signed long/unsigned long                  4   4       fourbyte (word)
    long long/signed long long/unsigned long long   8   4       eightbyte (doubleword)
    any-type*/any-type(*)()                         4   4       fourbyte
    float                                           4   4       single (IEEE-754)
    double/long double††††                          8   4       double (IEEE-754)
    __float80/long double††††                       12  4       80-bit extended (IEEE-754)
    __float128                                      16  16      128-bit extended (IEEE-754)
    _Complex float                                  8   4       complex single (IEEE-754)
    _Complex double/_Complex long double††††        16  4       complex double (IEEE-754)
    _Complex __float80/_Complex long double††††     24  4       complex 80-bit extended (IEEE-754)
    _Complex __float128                             32  16      complex 128-bit extended (IEEE-754)
    _Decimal32                                      4   4       32bit BID (IEEE-754R)
    _Decimal64                                      8   8       64bit BID (IEEE-754R)
    _Decimal128                                     16  16      128bit BID (IEEE-754R)
    __m64                                           8   8       MMX and 3DNow!
    __m128                                          16  16      SSE and SSE-2
    __m256                                          32  32      AVX
    __m512                                          64  64      AVX-512

    †††† 类型 long double 在 Android 平台上与 double 相同，都是 8 字节

Intel386 架构不需要双精度浮点值是8字节对齐的，但是为了兼容 x64 的数据结构，编译器可以将
它对齐到8字节边界。然而，这样生成的代码（包括数据结构和函数调用约定）是与 Intel386 ABI
不兼容的，违反了 Intel386 ABI。

80位浮点使用15位指数（exponent），64位尾数（mantissa），最高有效位是隐含的，指数的偏移
量为 16383。128位浮点使用15位指数，113位尾数，最高有效位是隐含的，指数的偏移量为 16383。
Intel386 架构的最初实现仅通过软件仿真来支持128位浮点类型的操作。

类型 size_t 被定义为 unsigned int。布尔类型当保存在内存中时，长度为1个字节，其值为 0
表示 false，1 表示 true。当存储在整型寄存器中时（除非传递参数），寄存器中所有 4 个字节
都是重要的，并且任何非零值都表示 true。

Intel386 并不需要所有的类型都是根据字节大小对齐的，对齐的数据访问速度只是比不对齐的快，
其他行为都是相同的。仅有的例外是 __float128、_Complex __float128、_Decimal128、__m128、
__m256、__m512 必须是严格对齐的。

结构体和联合体的对齐字节数是其成员的最大对齐地址数，每个成员位于满足对齐要求的最低偏移处。
任何对象的大小必须是对象对齐字节数的倍数。结构体和联合体可以通过填充来满足大小和对齐要求，
填充内容没有定义。因为成员对齐产生的填充称为内部填充（internal padding）。因为对象整体
大小必须是对象对齐字节整数倍产生的填充称为尾部填充（tail padding），与最后一个成员的大
小相关。下面是两种填充的例子： ::

    struct { // 结构体4字节对齐，大小16字节
        char c;
        double d;
        short s;
    };

      byte 3 | byte 2 | byte 1 | byte 0
    [    internal padding      |   c   ]
    [                 d                ]
    [                 d                ]
    [   tail padding  |        s       ]

位域
-----

C 语言中的结构体和联合体可以包含位域成员，它定义一个指定了比特位宽度的整型数据。位域类型
成员的值范围： ::

    位域类型                        比特位宽度（w）范围     值范围
    signed char/short/int/long          1 ~ 8/16/32     -2^(w-1) ~ 2^(w-1)-1
    char/unsigned char                  1 ~ 8           0 ~ (2^w)-1
    short/unsigned short                1 ~ 16          0 ~ (2^w)-1
    int/long/enum/unsigned int/long     1 ~ 32          0 ~ (2^w)-1

不加修饰的整型位域总是非负值，即使对应的类型 char、short、int、long 可以设置负值，但是
位域的结果总是与对应的 unsigned 类型相同。位域成员的大小和对齐规则与结构体或联合体成员
相同，并补充以下几点：

1. 位域按照定义顺序从地址最低位到最高位分配
2. 位域字段必须完全位域对应类型的存储单元内，不能跨越边界
3. 位域字段可以与其他成员共享存储单元，其他成员包括非位域成员，当然结构体成员占据存储单
   元的不同部分
4. 未命名位域成员不影响结构体或联合体的对齐，尽管位域字段的成员偏移需要满足对齐要求
5. 使用 int 类型位域最紧凑，它的成员偏移不需要对齐；而 char/short 类型位域不仅起始位置
   需要对齐，如果其后还有更多的成员，每个 char/short 类型位域必须占满一个 char/short

包含位域成员的结构体例子： ::

    struct {        // 结构体4字节对齐，大小是4字节
        int j:5;    // bit4 ~ bit0
        int k:6;    // bit10 ~ bit5
        int m:7;    // bit17 ~ bit11
    };              // bit31 ~ bit18 填充

    struct {        // 结构体4字节对齐，大小12字节
        short s:9;  // word0: bit8 ~ bit0
        int   j:9;  //        bit17 ~ bit9
                    //        bit23 ~ bit18 填充
        char  c;    //        byte3
        short t:9;  // word1: bit8 ~ bit0
                    //        bit15 ~ bit9 填充
        short u:9;  //        bit24 ~ bit16
                    //        bit31 ~ bit25
        char  d;    // word3: byte0
    };              //        byte3 ~ byte1 填充

    struct {        // 结构体2字节对齐，大小2字节
        char  c;    // byte0
        short s:8;  // byte1
    };

    struct {        // 结构体1字节对齐，大小9字节
        char  c;    // word0: byte0
        int   :0;   //        byte3 ~ byte1
        char  d;    // word1: byte0
                    //        byte1 填充
        short :9;   //        bit24 ~ bit16
                    //        bit31 ~ bit25 填充
        char  e;    // word2: byte0
        char  :0;   //        不占位置，因为没有下一个成员
    };

上例所示，int 型位域成员（包括 singed 和 unsigned）比更小的基本类型更紧凑。可以使用字
符型和短整型来强制特定的对齐，但 int 型通常更加高效。未命名位域表示的是，下一个成员必须
对齐到对应类型地址对齐要求的边界。

函数调用约定
=============

这部分介绍标准函数调用约定，包括栈帧布局、寄存器使用、参数传递等等。标准调用约定仅用于全
局函数。本地不会被其他编译单元访问的函数可以适用不同的约定，但还是推荐所有的函数都是用标
准调用约定。

寄存器
-------

Intel386 提供了一系列寄存器，整型寄存器和浮点寄存器简要描述如下： ::

    通用寄存器       用途                                         是否由被调函数保护可自动跨函数使用
    %eax            临时寄存器（scratch register），返回值                        否
    %ebx            本地寄存器（local register），当 PLT 调用函数时保存 GOT 指针  （是）
    %ecx            临时寄存器，计数寄存器（移位和字符串操作）                      否
    %edx            临时寄存器，被除数寄存器（除法操作），还用来返回高32位           否
    %ebp            栈基指针（可选）                                            （是）
    %esi            本地寄存器                                                 （是）
    %edi            本地寄存器                                                 （是）
    %esp            栈顶指针                                                   （是）
    %eflags         状态标记
    浮点寄存器
    %st(0) %mm0     临时寄存器，浮点栈顶，返回值                                   否
    %st(1) %mm1 ... 临时寄存器，浮点栈中                                          否
    %st(7) %mm7     临时寄存器，浮点栈底                                          否
    %fcw            浮点控制寄存器                                              （是）
    %fsw            浮点状态寄存器                                               否
    %gs             系统保留（作为线程特定数据寄存器）                             否
    单指多码寄存器
    %xmm0 ~ %xmm7   临时寄存器                                                   否
    %ymm0 ~ %ymm7   临时寄存器                                                   否
    %mxcsr          SSE2 控制位和状态位，只有控制位由被调函数保护                  部分
    %k0 ~ %k7       临时寄存器                                                   否

CPU 在进入函数之前必须是 x87 模式。因此每个用了 MMX 寄存器的函数，必须在使用完 MMX 寄
存器之后，并在函数返回或调用另一个函数之前，调用 emms 或 femms 指令。所有 x87 寄存器是
由调用者保存的，因此使用 MMX 寄存器的被调函数，可以使用更快的 femms 指令。

状态标记寄存器中的 df 位在函数入口处和返回时必须为 0（即方向向前），即由被调函数保存，可
以跨越函数。其他的标记在标准调用约定中没有指定，没有跨函数保护。MXCSR 寄存器的控制位由被
调函数保存，有跨函数保护；而状态位是由调用者保存的，没有跨函数保护。另外，x87 控制寄存器
是被调函数保存的，而 x87 的状态寄存器是调用者保存的。

Intel386 中的所有寄存器都是全局的，因此对所有调用者和被调函数都是可见的。其中 %ebp、%ebx、
%edi、%esi、%esp 属于调用者，也就是说被调函数使用这些值之前必须为调用者保护这些寄存器。
其余的寄存器属于被调函数，如果调用者需要跨函数使用这些寄存器，必须在调用函数前将这些寄存
器的值保存到它的栈帧里。

栈帧
-----

除了寄存器，每个函数都在运行时栈上有一个栈帧，这个栈从高地址向低地址扩展。下图示意了栈帧
的组织方式： ::

    位置            内容          栈帧
    4n+4(%ebp)      字长参数n    _______ 高地址栈底
                    ...          前一帧
       8(%ebp)      字长参数1    _______
       4(%ebp)      返回地址
       0(%ebp)      原%ebp (O)
      -4(%ebp)      未指定       当前帧
                    ...
       0(%esp)      大小不定     _______ 低地址栈顶

其中输入参数区域的结束位置必须对齐到16字节边界，当使用了 __m256 或 __m512 时必须对应到
32字节或64字节边界。换句话说，当控制权转移到函数入口时，(%esp + 4) 的值必须是16字节或
32字节或64字节的倍数。栈顶指针 %esp 总是指向当前最新分配的栈帧的尾部，即指向已经存有内
容的栈顶元素。使用 %esp 来索引栈帧内容可以避免寄存器 %ebp 作为帧指针使用。这种技术可以
在函数开头和结尾节省两条指令，并节省出一个额外的通用寄存器（%ebp）可用于其他用途。

栈是根据机器字长对齐的。大多数参数会使用栈传递，按照相反的顺序入栈，也就是 C 调用语法中
最左边的参数最后压入地址最低，最右边的参数最先压入地址最高。栈中所有的函数参数位于调用者
的栈帧中，即当前栈帧的前一帧。

参数的大小会在必要时增大，以使其大小为机器字长的倍数，这可能需要尾部填充，具体取决于参数
的大小。栈帧未指定的其他区域，跟编译器和正常被编译的代码相关，标准调用约定没有定义最大的
栈帧大小，也没有限制如果使用标准栈帧中的未指定区域。

在标准调用约定中，一些寄存器赋予了特定的角色：

%esp
    栈指针，指向当前栈帧的最后合法的机器字长地址处，即指向合法的栈顶元素。任何时候，栈顶
    指针都指向一个机器字长对齐的区域。
%ebp
    帧指针，指向当前栈帧的的基地址，也可称为栈基指针。当前函数的参数位于前一个函数的栈帧
    里，使用当前函数的栈基指针和正偏移访问。函数自己的局部变量位于当前栈帧，使用负偏移访
    问。被调函数必须为调用者保护这个寄存器的值。
%eax
    保存整型和指针类型返回值。如果返回值是结构体或联合体，该寄存器保存返回值的地址。否则，
    这是一个临时寄存器。
%ebx
    位置无关代码中，该寄存器用作全局偏移表的基寄存器。对应绝对位置代码，%ebx 用作本地寄
    存器没有特别的角色。但不管哪种情况，必须为调用者保护这个寄存器的值。
%esi %edi
    本地寄存器（local register）没有特别的角色，函数必须为调用者保护这个寄存器的值。
%ecx %edx
    临时寄存器（scratch register），函数不需要为调用者保护这个寄存器。
%st(0)
    浮点返回值位于浮点寄存器栈的栈顶寄存器中，浮点寄存器中的单双扩展精度值的表示都是相同
    的。如果函数不返回一个浮点值，这个寄存器必须为空。在进入一个函数之前，这个寄存器也必
    须为空。
%st(1) ~ %st(7)
    浮点临时寄存器，这些寄存器在进入和退出函数前都必须为空。
EFLAGS
    标记 bf 必须在进入和退出函数前都置为 0，其他标记没有指定特别角色被调函数不需要保护
    这些值。
fcw (control word)
    Intel387 浮点控制寄存器包含一些浮点控制位，例如舍入模式和异常掩码。

信号（Signal）可以打断进程，在信号处理期间调用的函数，其可以使用的寄存器没有特别额外限
制。此外，当信号处理返回之后，进程将恢复其原本执行路径，并恢复寄存器的值。因此，程序和编
译器可以自由使用所有寄存器，而不必担心信号处理程序会修改它们的值。

传参
-----

当所有的参数求值完毕后，它们会被传到寄存器或压到栈中。大多数参数会使用栈传递，并按照相反
顺序入栈。为了满足类型的对齐要求，可能需要使用填充来增加参数的大小。一个列外是，当 __m64
和 _Decimal64 作为参数使用时，只需要对齐到 4 字节。另外还可能需要额外的填充，以使得在参
数之后的栈地址满足16字节地址对齐要求。如果参数中包含需要通过栈传递的 __m256 或者 __m512
类型，由所有通过栈传递的参数组成的结构体必须对齐到32字节或64字节地址处。即 (%esp+4) 的
值必须是16字节或32字节或64字节的倍数。

通过栈传参的例外情况如下：

1. 前 3 个 __m64 类型的参数通过寄存器 %mm0、%mm1、%mm2 传参
2. 前 3 个 __m128 类型的参数通过寄存器 %xmm0、%xmm1、%xmm2 传参
3. 因为 SSE、AVX、AVX-512 寄存器的低位是共享的，第一个 __m128 类型的参数会赋给 %xmm0，
   然后如果还存在第一个 __m256 或 __m512 类型的参数会赋给 %ymm1 或 %zmm1 而不是 %ymm0
   或 %zmm0

通过内存栈传递的参数，第一个参数位于 8(%ebp)，第二个参数位于 12(%ebp)，依次类推。传递
的所有整型参数都会转换成一个字长，将小于字长的参数值的符号位或零比特位扩展到高位。而单精
度浮点适用一个字长，双精度浮点适用两个字长，扩展精度浮点适用三个字长。对于结构体和联合体
参数，每个参数的大小必须扩展到字长的整数倍。

可变参数传递
------------

一些本来可以移植的 C 程序依赖于参数传递方案，隐含地假定所有参数都通过内存栈传递，并且参
数在栈上的顺序是按地址顺序升序排列的。这在 Intel386 上不具备可移植性，因为有些参数是通
过寄存器传递的。为了处理可变参数列表，可移植的 C 程序必须使用头文件 <stdarg.h>。

当调用接受可变参数的函数时，所有参数都通过栈传递，包括 __m64、__m128、__m256 等等。这
一规则适用于命名和未命名参数。由于参数的传递方式取决于被调用函数是否接受可变参数列表，因
此这些函数必须正确地进行声明，不这样做将导致未定义的行为。

返回值
-------

下表列出了每个基本类型返回值以怎样的方式返回。结构体和联合体这些复合类型总是通过内存值返
回。浮点返回值通过 x87 寄存器栈中的栈顶寄存器 %st(0) 返回。调用者需要负责从寄存器栈中弹
出该值，不管该浮点返回值是否真实使用。如果没这样做，将导致未定义行为。这一个要求的一个含
义是，返回浮点值的函数必须正确进行函数原型声明。 当 _Bool 类型值返回或者通过寄存器或内存
传递，字节中的比特 0 包含真值，比特 1~7 必须为零。 ::

    C 语言类型                              返回值位置
    _Bool/char/signed/unsigned              %al，高24位未定义
    short/signed/unsigned                   %ax，高16位未定义
    int/signed/enum/unsigned/long           %eax
    long long/signed/unsigned               %edx:%eax，高32位在 %edx 寄存器中
    any-type */any-type (*)()               %eax
    float/double/long double/__float80      %st(0)
    __float128                              内存
    __Complex float                         %edx:%eax，其中 %edx 是虚数部分，%eax 是实数部分
    __Complex [long] double/__float80/128   内存
    _Decimal32                              %eax
    _Decimal64                              %edx:%eax，高32位在 %edx 寄存器中
    _Decimal128                             内存
    __m64                                   %mm0
    __m128                                  %xmm0
    __m256                                  %ymm0
    __m512                                  %zmm0

没有返回值的函数不会写特别的返回值到任何寄存器。call 指令会将下一条指令的地址压入栈中，
也即被调函数执行完后的返回地址。ret 指令会将返回地址弹出栈并继续执行 call 指令后的下一
条指令。以下是进入被调函数之后，开始以及最后执行的代码，被调函数需要包含上文提到的 5 个
寄存器 %ebp、%ebx、%edi、%esi、%esp，这里还假设分配 80 个字节的额外栈空间来适用； ::

        return address      / 函数调用者压入的继续执行地址
    prologue:
        pushl %ebp          / 保存栈基指针
        movl %esp,%ebp      / 设置当前的栈基指针
        subl $80, %esp      / 分配80字节栈空间
        pushl %edi          / 保护寄存器
        pushl %esi          / 保护寄存器
        pushl %ebx          / 保护寄存器

        movl %edi,%eax      / 寄存器返回值示例
    epilogue:
        popl %ebx           / 恢复寄存器
        popl %esi           / 恢复寄存器
        popl %edi           / 恢复寄存器
        leave               / 恢复栈基指针
        ret                 / 弹出返回地址，跳到返回地址继续执行（即 call 的下一条指令）

虽然一些函数可能被优化不保存和恢复栈基指针，但一般情况还是使用上面标准的开始和结束代码。
位置无关的代码适用 %ebx 寄存器保存全局偏移表的地址。如果一个函数直接或间接需要全局偏移
表的地址，它负责计算这个值。

一些基本类型和所有的复合类型返回值通过使用内存进行返回。返回值如果通过内存返回，函数调用
者负责传递内存返回位置的地址，这个地址通过第一个隐式参数传递给被调函数。让调用者提供返回
对象的空间允许重入。该地址必须满足数据对象的地址对齐要求。被调函数需要将返回值写到给定的
内存地址，并且要负责在返回前将隐式参数从栈中弹出并保存到 %eax 寄存器中。函数调用者可能在
函数返回后获取 %eax 的值来当作返回值的引用。这里的结构体和联合体复合类型是固定大小的，当
前 ABI 没有指定怎样处理变长数据对象。

下面展示了被调函数接受到控制权后（call 指令执行之后），以及调用者重新获得控制权后（ret
指令执行之后）的栈内容： ::

    栈位置      call 指令之后   ret 指令之后    栈位置
    4n+4(%esp)  字长参数n       字长参数n       4n-4(%esp)
                ...             ...
       8(%esp)  字长参数1       字长参数1       0(%esp)
       4(%esp)  内存返回值地址
       0(%esp)  函数返回地址

下面的例子是在上文函数开始和结束代码的基础上，加上对内存返回值地址的处理： ::

        value address       / 内存返回值地址
        return address      / 函数调用者压入的继续执行地址
    prologue:
        popl %eax           / 将函数返回值地址出栈保存到 %eax
        xchgl %eax,0(%esp)  / 将内存返回值地址保存到 %eax，%eax 原本的返回地址保存到栈顶
        pushl %ebp          / 保存栈基指针
        movl %esp,%ebp      / 设置当前的栈基指针
        subl $80, %esp      / 分配80字节栈空间
        pushl %edi          / 保护寄存器
        pushl %esi          / 保护寄存器
        pushl %ebx          / 保护寄存器
        movl %eax,-4(%ebp)  / 将内存返回值地址保存到第一个局部变量中

    epilogue:
        movl -4(%ebp),%eax  / 将内存返回值地址恢复到 %eax 寄存器中
        popl %ebx           / 恢复寄存器
        popl %esi           / 恢复寄存器
        popl %edi           / 恢复寄存器
        leave               / 恢复栈基指针
        ret                 / 弹出返回地址，跳到返回地址继续执行（即 call 的下一条指令）

参数传递和返回值的一个例子： ::

    typedef struct {
        int a, b;
        double d;
    } structparam;
    structparam s;
    int i;
    __m128 v, x, y;
    __m256 w, z;
    extern structparam func(int i, __m128 v, structparam s, __m256 w, __m128 x, __m128 y, __m256 z);
    func(i, v, s, w, x, y, z);

函数参数的寄存器分配： ::

                    函数调用前参数传递位置
    内存返回地址        内存，位于 (%esp)
    i                  内存，位于 4(%esp)
    v                  %xmm0
    s                  内存，位于 8(%esp)
    w                  %ymm1
    x                  %xmm2
    y                  内存，位于 32(%esp)，因为 __m128 需要对齐到16字节边界
    z                  内存，位于 64(%esp)，因为 __m256 需要对齐到32字节边界

栈帧布局： ::

    内容            长度
    z               32个字节
    padding         16个字节
    y               16个字节
    padding         8个字节
    s               16个字节
    i               4个字节
    内存返回地址     4个字节 <--- %esp (对齐到32字节边界)

操作系统接口
============

虚拟地址空间
------------

进程在32位虚拟地址空间中执行，内存管理将虚拟地址转换位物理地址，隐藏物理寻址并允许进程在
系统的真实内存中的任何位置允许。进程通常以三个逻辑段开始，即代码段、数据段、栈。动态链接
器在执行期间可以创建更多的段，进程也可以适用系统服务为自己创建额外的段。

内存通过页面的形式进行组织，这是系统内存分配的最小单位。页面大小可能因系统而异，这取取决
于处理器、内存管理单元、和系统配置。进程可以调用 sysconf(BA_OS) 过程确定系统当前的页面
大小。

在概念上讲，进程拥有全部的32为地址空间。然而在实践中，由几个因素限制了进程的大小：

1. 系统预留了于配置相关的一定量的虚拟空间
2. 系统为每个进程预留了与配置相关的一部分空间
3. 如果一个进程的大小超出了系统可用的，包含了物理内存和辅助存储空间，进行将无法允许；尽
   管运行任何进程都需要一些物理内存空间，但系统可以执行比物理内存大的进程，将它们分页到
   辅助存储中。尽管如此，物理内存和辅助存储空间都是共享资源，只要有系统进程执行负载可用
   的空间就会减少

处理器执行模式
--------------

异常接口
---------

进程初始化
-----------


目标文件
=========

文件头部
---------

文件标识信息字段 e_ident，Intel386 架构要求的值如下： ::

    字段                值
    e_ident[EI_CLASS]   ELFCLASS32      32位机器数据类型
    e_ident[EI_DATA]    ELFDATA2LSB     二进制补码小端字节序

处理器信息字段 e_machine 的值必须是 EM_386；处理器标记 e_flags 由于 Intel386 没有定
义标记，该值为零。


特殊分区
---------

各种不同的分区包含有程序和控制信息，下面列出的是系统使用的分区： ::

    分区名称         分区类型            分区属性
    .got            SHT_PROGBITS        SHF_ALLOC|WRITE
    .plt            SHT_PROGBITS        SHF_ALLOC|EXECINSTR

.got
    该分区包含全局偏移表

.plt
    该分区包含过程链接表


符号表分区
-----------

如果一个可执行文件引用了一个定义在共享目标文件中的函数，符号表中会包含这个引用符号。其中
的 st_shndx 字段的值为 SHN_UNDEF，表示这个符号没有定义在这个可执行文件中。如果这个符号
在过程链接表中分配了一个条目，并且 st_value 字段的值不是零，那么这个值是过程链接表对应
条目第一条指令的虚拟地址。否则 st_value 字段的值为零。这个过程链接表条目的地址，被动态
链接器用来解析函数地址引用。

重定位类型
-----------

重定位结构体字段 r_offset 指定了受影响存储单元第一个字节的文件偏移或虚拟地址。Intel386
架构只是用 Elf32_Rel 这个重定位结构体，附加值保存在被重定位字段中。

重定位结构体中的重定位类型指定了怎样修改以下的数据字段：

    word32

该数据字段的值，是在链接编辑器将一个或多个重定位文件合并到一个可执行文件或共享目标文件的
过程中计算的。概念上，链接器首先决定怎样合并和定位这些输入文件，然后更新符号的值，最后执
行重定位。应用到可执行文件或共享目标文件的重定位是类似的，都产生相同的结果。

Intel386 定义的重定位类型如下。其中 A 表示附加值；B 表示基地址，共享目标文件的基地址是
零，可执行文件的基地址则不同；G 表示相对全局偏移表的偏移，其中保存的是重定位符号最终执行
的地址；GOT 表示全局偏移表的地址；L 表示重定位符号的过程链接表条目的偏移或地址，过程链接
表条目将一个函数调用重定位到合适的目标，链接编辑器会创建一个初始的过程链接表，然后动态链
接器会在执行过程中修改它；P 表示使用 r_offset 计算的被重定位后的存储单元的偏移或地址；
而 S 是重定位符号的值。 ::

                            数据字段    计算方式
    R_386_NONE      0       无          无
    R_386_32        1       word32      S + A
    R_386_PC32      2       word32      S + A - P
    R_386_GOT32     3       word32      G + A - P
    R_386_PLT32     4       word32      L + A - P
    R_386_COPY      5       无          无
    R_386_GLOB_DAT  6       word32      S
    R_386_JMP_SLOT  7       word32      S
    R_386_RELATIVE  8       word32      B + A
    R_386_GOTOFF    9       word32      S + A - GOT
    R_386_GOTPC     10      word32      GOT + A - P

下面这些重定位类型有除以上计算方式之外的含义：

R_386_GOT32
    计算的是符号的全局偏移表条目相对全局偏移表的偏移，可以辅助链接编辑器创建全局偏移表
R_386_PLT32
    计算的是符号的过程链接表条目的地址，用来辅助链接编辑器创建过程链接表
R_386_COPY
    链接编辑器创建这种重定位类型用于动态链接，其中的 r_offset 字段指向的是一个可写字段
    位置。重定位符号必须存在于当前的目标文件以及共享目标文件中，在执行时，动态链接器会拷
    贝共享目标文件中的符号到 r_offset 指定的字段中
R_386_GLOB_DAT
    该重定位类型用于将符号的地址设置到全局偏移表条目中
R_386_JMP_SLOT
    链接编辑器创建这种重定位类型用于动态链接，其中的 r_offset 字段是过程链接表条目的地
    址。动态链接器修改过程链接表条目从而将控制权转移到符号的地址
R_386_RELATIVE
    链接编辑器创建这种重定位类型用于动态链接，其中的 r_offset 字段是共享目标文件中的一
    个位置。动态链接器会基于共享目标文件所在的虚拟地址来计算符号的虚拟地址。该类型的重定
    位结构体中的符号索引必须设置为 0
R_386_GOTOFF
    计算的是符号值与全局编译表的偏移，用来辅助链接编辑器创建全局偏移表
R_386_GOTPC
    该重定位类型类似于 R_386_PC32，唯一不同的是使用全局偏移表的地址进行计算。该类型的重
    定位符号一般是 _GLOBAL_OFFSET_TABLE_，它用来辅助链接编辑器创建全局偏移表

程序加载
=========

当系统创建程序映像时，逻辑上是将一个文件的分段拷贝到一个虚拟内存分段。但是系统什么时候以
及是否物理地读取文件，依赖于程序的执行行为。进程在真正引用对应的逻辑页之前不需要分配一个
物理页，而且进程通常会留下很多未引用的页。因此延迟物理读取可以提升系统性能，为了在实践中
获得这种效率，可执行文件和共享目标文件中的分段映像的文件偏移或虚拟地址必须同余到内存页面
大小，即它们除以页大小之后的余数相同。

Intel386 最大的页面大小是 4KB（0x1000），因此分段必须同余到 4KB 或更大的2的幂。下面是
一个可执行文件分段的例子： ::

    文件偏移      文件内容       虚拟地址
          0     ELF 文件头部
                程序头部表
                其他头部信息
      0x100     代码段...       0x8048100
                0x2be00字节     0x8073eff
    0x2bf00     数据段...       0x8074f00
                0x4e00字节      0x8079cff
    0x30d00     其他信息

该可执行文件包含了一个代码段和一个数据段，根据上面的内容程序头部表中需要包含： ::

    程序头部结构体   代码段       数据段
        p_type      PT_LOAD     PT_LOAD
        p_offset    0x100       0x2bf00
        p_vaddr     0x8048100   0x8074f00
        p_paddr     0           0
        p_filesz    0x2be00     0x4e00
        p_memsz     0x2be00     0x5e24
        p_flags     PF_R|PF_X   PF_R|PF_W|PF_X
        p_align     0x1000      0x1000

加载后的进程映像段： ::

        虚拟地址     代码段
        0x8048000   头部填补
                    0x100字节
        0x8048100   代码段内容
                    0x2be00字节
        0x8073f00   数据填补
                    0x100字节

                    数据段
        0x8074000   代码填补
                    0xf00字节
        0x8074f00   数据段内容
                    0x4e00字节
        0x8079d00   未初始化数据
                    0x1024字节（全零）
        0x807ad24   页面填补
                    0x2dc字节（全零）

加载共享目标文件与加载可执行文件的一点不同是，共享目标文件段包含的是位置无关的代码，使得
分段的虚拟地址随着实际进程的不同而变化。尽管系统为每个进程单独选择虚拟地址，但是还是会维
护与分段的相对位置关系。因为位置无关代码在分段之间使用相对地址，内存虚拟地址页必须匹配这
种相对关系。下表示意了多个进程虚拟地址固定的相对位置关系，以及基地址的计算。 ::

                    文本段        数据段           基地址
    共享目标文件      0x200         0x2a400            0x00
    进程1       0x80000200      0x8002a400      0x80000000
    进程2       0x80081200      0x800ab400      0x80081000
    进程3       0x900c0200      0x900ea400      0x900c0000
    进程4       0x800c6200      0x900f0400      0x900c6000


动态链接
=========

程序解释器
-----------

满足 Intel386 ABI 规范的程序解释器： ::

    /usr/lib/libc.so.1

动态链接段
-----------

动态链接段的内容由动态链接结构体组成，这些内容为动态链接器提供信息。这些信息有些是处理器
相关的，包含结构体里面一些字段的解释。其中标签 DT_PLTGOT 表示该结构体保存的时过程链接表
或全局偏移表的地址。在 Intel386 架构上，该结构体的 d_ptr 字段给出的是全局偏移表的地址，
在后面可以看到，全局偏移表中前三个条目是预留的，其中的两个用来保存过程链接表的信息。

全局偏移表
-----------

总体上，位置无关的代码不能包含绝对虚拟地址。而全局偏移表保存的绝对地址是私有数据，因此使
得这些地址也不违背位置无关以及程序代码的共享要求。程序使用位置无关的地址来引用全局偏移表，
然后获得对应地址的绝对值，这样可以将位置无关的引用重定向到绝对位置。

初始状态下，全局偏移表保存着重定位条目所需的信息。当系统为可加载对象文件创建内存分段后，
动态链接器处理重定位条目，这其中有一些是引用全局偏移表的 R_386_GLOB_DAT 重定位类型。动
态链接器确定关联的符号的值，并计算符号的绝对地址，并设置到全局偏移表中。尽管绝对地址在链
接编辑器创建目标文件时时未知的，动态链接器知道所有内存分段的地址，因而可以计算出符号的绝
对地址。

如果程序需要直接访问符号的绝对地址，这个符号就需要一个全局偏移表条目。因为可执行文件和共
享目标文件的全局偏移表是分离的，一个符号的地址可能出现在多个表中。动态链接器会在将控制权
交给程序映像之前处理所有的全局偏移表重定位，因而绝对地址在执行时可用。

全局偏移表的第一个条目用来保存动态结构体数组的地址，即符号 _DYNAMIC 引用的数组。在 Intel386
架构上，第二个和第三个条目也是保留的，见下面的过程链接表部分。

系统可以给相同的共享目标选择不同的内存分段地址，甚至会为同一个程序的不同执行选择不同的库
地址。但不管怎样，内存分段在程序映像构建好之后就不会再改变。在进程退出之前，进程的内存分
段都位于固定的虚拟地址上。

一个全局偏移表的格式以及如何解析式处理器相关的，对于 Intel386 架构，以下这个符号可以用
来访问全局偏移表： ::

    extern Elf32_Addr _GLOBAL_OFFSET_TABLE_[];

这个符号可能位于 .got 分区的中间，允许基于这个数组地址的负数或非负数索引访问。

函数地址
---------

在可执行文件和共享目标文件中引用一个函数的地址，可能不会解析到同一个值。在共享目标对象中，
动态链接器通常解析到该函数自己的虚拟地址上。而可执行文件中引用一个共享目标文件中的函数，
通常被链接编辑器解析到过程链接表条目的地址。

为了使函数地址的比较能正常工作，如果可执行文件引用了一个共享目标文件中的函数，链接编辑器
会将该函数对应的过程链接表条目的地址写入到函数符号中。动态链接器会特殊对待这种符号，当链
接编辑器搜索到该符号时，通常会按以下规则处理：

1. 如果符号的 st_shndx 字段不是 SHN_UNDEF，表示找到了该符号的定义，则使用 st_value 的
   值作为符号的地址
2. 如果 st_shndx 的值是 SHN_UNDEF，并且符号的类型是 STT_FUNC，st_value 的值不是 0，
   那么也是用 st_value 的值作为符号的地址
3. 否则，动态链接器认为这个符号在这个可执行文件中是未定义的，将继续处理

一个重定位被关联到链接过程表的条目中，这些条目用来直接函数调用而不是引用函数地址。这些重
定位不会按上面的规则特殊对待，因为动态链接器禁止将过程链接表条目重定向到它们自己身上。

过程链接表
-----------

类似于全局偏移表将位置无关的地址重定向到绝对地址，过程链接表将位置无关的函数调用重定向到
绝对地址。链接编辑器不能解决一个可执行目标到另一个的执行转移（例如函数调用），它只能将程
序的转移控制放到过程链接表条目中。

在 Intel386 架构中，过程链接表位于共享代码中，但是使用私有的全局偏移表中的地址。动态链
接器会确定目标的绝对地址并且据此修改全局偏移表的内存映像。从而可以重定向条目而不违反程序
代码的位置无关和共享。可执行文件和共享目标文件有各自的过程链接表。

绝对过程链接表： ::

    .PLT0: pushl got_plus_4
           jmp *got_plus_8
           nop; nop
           nop; nop
    .PLT1: jmp *name1_in_GOT
           pushl $offset
           jmp .PLT0@PC
    .PLT2: jmp *name2_in_GOT
           pushl $offset
           jmp .PLT0@PC
           ...

位置无关的过程链接表： ::

    .PLT0: pushl 4(%ebx)
           jmp *8(%ebx)
           nop; nop
           nop; nop
    .PLT1: jmp *name1@GOT(%ebx)
           pushl $offset
           jmp .PLT0@PC
    .PLT2: jmp *name2@GOT(%ebx)
           pushl $offset
           jmp .PLT0@PC
           ...

根据一些步骤，动态链接器和程序一起使用过程链接表和全局偏移表来解决符号引用：

1. 当第一次创建程序的内存映像时，动态链接器将全局便宜表的第二个和第三个条目设置为特殊值
2. 如果过程链接表时位置无关的，全局偏移表的地址必须位于 %ebx 寄存器中。每个进程映像中的
   共享目标文件都有自己的过程链接表，到一个过程链接表条目的控制转移只能发生在相同目标文
   件内部。因此，主调函数需要负责在调用过程链接表条目之前设置全局偏移表的基寄存器
3. 假如有一个名为 name1 的程序，它将控制权转移到标签 .PLT1
4. 第一条指令跳转到 name1 对应的全局偏移表条目的地址，初始化时全局偏移表保存的是下面的
   pushl 指令的地址，而不是 name1 的真正地址
5. 因此，程序将重定位偏移（offset）入栈，重定位偏移是一个32位的基于重定位表的字节偏移。
   对应的重定位类型是 R_386_JMP_SLOT，并且其中偏移字段的值就是对应的全局偏移表条目的偏
   移。重定位条目还包含符号索引，告诉动态链接器是哪个符号被引用，这里是 name1
6. 然后程序会跳转到 .PLT0，即过程链接表的第一个条目。pushl 指令会将第二个全局偏移表条目
   的值入栈，然后程序跳转到全局偏移表的第三个条目的地址，这时会将控制权交给动态链接器
7. 动态链接器接收到控制权后，它会展开栈，查看重定位条目，找到符号的值，将 name1 真实的
   地址保存到对应的全局偏移表条目中，并且将控制权转移给要求的目标

环境变量 LD_BIND_NOW 可以改变动态链接的值，如果这个值不为空，动态链接器会在将控制权交给
前程之前对过程链接表求值。也就是，动态链接器会在进程初始化时处理类型为 R_386_JMP_SLOT
的重定位条目。否则，动态链接器会延迟对过程链接表求值，会将符号解析和重定位推迟到过程链接
表条目的第一次执行。

延迟绑定会提高总体应用程序性能，因为未使用的符号不会引起额外的动态链接开销。然而，两种情
况使延迟绑定时对一些应用程序是不可接受的。第一种情况，因为动态链接器会拦截函数的调用来解
析对应的函数符号，一些应用程序受不了这种开销。第二种情况是，如果动态链接器找不到对应的符
号会终止程序，而在延迟绑定情况下，这种错误情况的发生是任意的，一些应用程序不能容忍这种不
确定性。通过关闭延迟绑定，动态链接器会在将控制权交给应用程序之前处理进程初始化时就强制报
出所有发生的错误。
