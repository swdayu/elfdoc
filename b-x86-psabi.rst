
底层系统信息
=============

寄存器和栈帧
-------------

Intel386 提供了一些列寄存器，整型寄存器和浮点寄存器简要描述如下： ::

    通用寄存器       用法
    %eax            返回值
    %edx            被除数寄存器（除法操作）
    %ecx            计数寄存器（移位和字符串操作）
    %ebx            局部寄存器变量
    %ebp            栈基指针（可选）
    %esi            局部寄存器变量
    %edi            局部寄存器变量
    %esp            栈顶指针
    浮点寄存器
    %st(0)          浮点栈顶，返回值
    %st(1)          浮点栈中
    ...             ...
    %st(7)          浮点栈底

除了寄存器，每个函数都在运行时栈上有一个栈帧，这个栈从高地址向低地址扩展。下图示意了栈帧
的组织方式： ::

    位置            内容          栈帧
    4n+8(%ebp)      参数n       ——————— 高地址栈底
                    ...         前一帧
       8(%ebp)      参数0       _______
       4(%ebp)      返回地址
       0(%ebp)      原%ebp (O)  当前帧
      -4(%ebp)      未指定
       0(%esp)      ...         _______ 低地址栈顶


目标文件
=========

文件头部
---------

文件标识信息字段 e_ident，Intel386 架构要求的值如下： ::

    字段                值
    e_ident[EI_CLASS]   ELFCLASS32      32位机器数据类型
    e_ident[EI_DATA]    ELFDATA2LSB     二进制补码小端字节序

处理器信息字段 e_machine 的值必须是 EM_386；处理器标记 e_flags 由于 Intel386 没有定
义标记，该值为零。


特殊分区
---------

各种不同的分区包含有程序和控制信息，下面列出的是系统使用的分区： ::

    分区名称         分区类型            分区属性
    .got            SHT_PROGBITS        SHF_ALLOC|WRITE
    .plt            SHT_PROGBITS        SHF_ALLOC|EXECINSTR

.got
    该分区包含全局偏移表

.plt
    该分区包含过程链接表


符号表分区
-----------

如果一个可执行文件引用了一个定义在共享目标文件中的函数，符号表中会包含这个引用符号。其中
的 st_shndx 字段的值为 SHN_UNDEF，表示这个符号没有定义在这个可执行文件中。如果这个符号
在过程链接表中分配了一个条目，并且 st_value 字段的值不是零，那么这个值是过程链接表对应
条目第一条指令的虚拟地址。否则 st_value 字段的值为零。这个过程链接表条目的地址，被动态
链接器用来解析函数地址引用。

重定位类型
-----------

重定位结构体字段 r_offset 指定了受影响存储单元第一个字节的文件偏移或虚拟地址。Intel386
架构只是用 Elf32_Rel 这个重定位结构体，附加值保存在被重定位字段中。

重定位结构体中的重定位类型指定了怎样修改以下的数据字段：

    word32

该数据字段的值，是在链接编辑器将一个或多个重定位文件合并到一个可执行文件或共享目标文件的
过程中计算的。概念上，链接器首先决定怎样合并和定位这些输入文件，然后更新符号的值，最后执
行重定位。应用到可执行文件或共享目标文件的重定位是类似的，都产生相同的结果。

Intel386 定义的重定位类型如下。其中 A 表示附加值；B 表示基地址，共享目标文件的基地址是
零，可执行文件的基地址则不同；G 表示相对全局偏移表的偏移，其中保存的是重定位符号最终执行
的地址；GOT 表示全局偏移表的地址；L 表示重定位符号的过程链接表条目的偏移或地址，过程链接
表条目将一个函数调用重定位到合适的目标，链接编辑器会创建一个初始的过程链接表，然后动态链
接器会在执行过程中修改它；P 表示使用 r_offset 计算的被重定位后的存储单元的偏移或地址；
而 S 是重定位符号的值。 ::

                            数据字段    计算方式
    R_386_NONE      0       无          无
    R_386_32        1       word32      S + A
    R_386_PC32      2       word32      S + A - P
    R_386_GOT32     3       word32      G + A - P
    R_386_PLT32     4       word32      L + A - P
    R_386_COPY      5       无          无
    R_386_GLOB_DAT  6       word32      S
    R_386_JMP_SLOT  7       word32      S
    R_386_RELATIVE  8       word32      B + A
    R_386_GOTOFF    9       word32      S + A - GOT
    R_386_GOTPC     10      word32      GOT + A - P

下面这些重定位类型有除以上计算方式之外的含义：

R_386_GOT32
    计算的是符号的全局偏移表条目相对全局偏移表的偏移，可以辅助链接编辑器创建全局偏移表
R_386_PLT32
    计算的是符号的过程链接表条目的地址，用来辅助链接编辑器创建过程链接表
R_386_COPY
    链接编辑器创建这种重定位类型用于动态链接，其中的 r_offset 字段指向的是一个可写字段
    位置。重定位符号必须存在于当前的目标文件以及共享目标文件中，在执行时，动态链接器会拷
    贝共享目标文件中的符号到 r_offset 指定的字段中
R_386_GLOB_DAT
    该重定位类型用于将符号的地址设置到全局偏移表条目中
R_386_JMP_SLOT
    链接编辑器创建这种重定位类型用于动态链接，其中的 r_offset 字段是过程链接表条目的地
    址。动态链接器修改过程链接表条目从而将控制权转移到符号的地址
R_386_RELATIVE
    链接编辑器创建这种重定位类型用于动态链接，其中的 r_offset 字段是共享目标文件中的一
    个位置。动态链接器会基于共享目标文件所在的虚拟地址来计算符号的虚拟地址。该类型的重定
    位结构体中的符号索引必须设置为 0
R_386_GOTOFF
    计算的是符号值与全局编译表的偏移，用来辅助链接编辑器创建全局偏移表
R_386_GOTPC
    该重定位类型类似于 R_386_PC32，唯一不同的是使用全局偏移表的地址进行计算。该类型的重
    定位符号一般是 _GLOBAL_OFFSET_TABLE_，它用来辅助链接编辑器创建全局偏移表

程序加载
=========

当系统创建程序映像时，逻辑上是将一个文件的分段拷贝到一个虚拟内存分段。但是系统什么时候以
及是否物理地读取文件，依赖于程序的执行行为。进程在真正引用对应的逻辑页之前不需要分配一个
物理页，而且进程通常会留下很多未引用的页。因此延迟物理读取可以提升系统性能，为了在实践中
获得这种效率，可执行文件和共享目标文件中的分段映像的文件偏移或虚拟地址必须同余到内存页面
大小，即它们除以页大小之后的余数相同。

Intel386 最大的页面大小是 4KB（0x1000），因此分段必须同余到 4KB 或更大的2的幂。下面是
一个可执行文件分段的例子： ::

    文件偏移      文件内容       虚拟地址
          0     ELF 文件头部
                程序头部表
                其他头部信息
      0x100     代码段...       0x8048100
                0x2be00字节     0x8073eff
    0x2bf00     数据段...       0x8074f00
                0x4e00字节      0x8079cff
    0x30d00     其他信息

该可执行文件包含了一个代码段和一个数据段，根据上面的内容程序头部表中需要包含： ::

    程序头部结构体   代码段       数据段
        p_type      PT_LOAD     PT_LOAD
        p_offset    0x100       0x2bf00
        p_vaddr     0x8048100   0x8074f00
        p_paddr     0           0
        p_filesz    0x2be00     0x4e00
        p_memsz     0x2be00     0x5e24
        p_flags     PF_R|PF_X   PF_R|PF_W|PF_X
        p_align     0x1000      0x1000

加载后的进程映像段： ::

        虚拟地址     代码段
        0x8048000   头部填补
                    0x100字节
        0x8048100   代码段内容
                    0x2be00字节
        0x8073f00   数据填补
                    0x100字节

                    数据段
        0x8074000   代码填补
                    0xf00字节
        0x8074f00   数据段内容
                    0x4e00字节
        0x8079d00   未初始化数据
                    0x1024字节（全零）
        0x807ad24   页面填补
                    0x2dc字节（全零）

加载共享目标文件与加载可执行文件的一点不同是，共享目标文件段包含的是位置无关的代码，使得
分段的虚拟地址随着实际进程的不同而变化。尽管系统为每个进程单独选择虚拟地址，但是还是会维
护与分段的相对位置关系。因为位置无关代码在分段之间使用相对地址，内存虚拟地址页必须匹配这
种相对关系。下表示意了多个进程虚拟地址固定的相对位置关系，以及基地址的计算。 ::

                    文本段        数据段           基地址
    共享目标文件      0x200         0x2a400            0x00
    进程1       0x80000200      0x8002a400      0x80000000
    进程2       0x80081200      0x800ab400      0x80081000
    进程3       0x900c0200      0x900ea400      0x900c0000
    进程4       0x800c6200      0x900f0400      0x900c6000


动态链接
=========

程序解释器
-----------

满足 Intel386 ABI 规范的程序解释器： ::

    /usr/lib/libc.so.1

动态链接段
-----------

动态链接段的内容由动态链接结构体组成，这些内容为动态链接器提供信息。这些信息有些是处理器
相关的，包含结构体里面一些字段的解释。其中标签 DT_PLTGOT 表示该结构体保存的时过程链接表
或全局偏移表的地址。在 Intel386 架构上，该结构体的 d_ptr 字段给出的是全局偏移表的地址，
在后面可以看到，全局偏移表中前三个条目是预留的，其中的两个用来保存过程链接表的信息。

全局偏移表
-----------

总体上，位置无关的代码不能包含绝对虚拟地址。而全局偏移表保存的绝对地址是私有数据，因此使
得这些地址也不违背位置无关以及程序代码的共享要求。程序使用位置无关的地址来引用全局偏移表，
然后获得对应地址的绝对值，这样可以将位置无关的引用重定向到绝对位置。

初始状态下，全局偏移表保存着重定位条目所需的信息。当系统为可加载对象文件创建内存分段后，
动态链接器处理重定位条目，这其中有一些是引用全局偏移表的 R_386_GLOB_DAT 重定位类型。动
态链接器确定关联的符号的值，并计算符号的绝对地址，并设置到全局偏移表中。尽管绝对地址在链
接编辑器创建目标文件时时未知的，动态链接器知道所有内存分段的地址，因而可以计算出符号的绝
对地址。

如果程序需要直接访问符号的绝对地址，这个符号就需要一个全局偏移表条目。因为可执行文件和共
享目标文件的全局偏移表是分离的，一个符号的地址可能出现在多个表中。动态链接器会在将控制权
交给程序映像之前处理所有的全局偏移表重定位，因而绝对地址在执行时可用。

全局偏移表的第一个条目用来保存动态结构体数组的地址，即符号 _DYNAMIC 引用的数组。在 Intel386
架构上，第二个和第三个条目也是保留的，见下面的过程链接表部分。

系统可以给相同的共享目标选择不同的内存分段地址，甚至会为同一个程序的不同执行选择不同的库
地址。但不管怎样，内存分段在程序映像构建好之后就不会再改变。在进程退出之前，进程的内存分
段都位于固定的虚拟地址上。

一个全局偏移表的格式以及如何解析式处理器相关的，对于 Intel386 架构，以下这个符号可以用
来访问全局偏移表： ::

    extern Elf32_Addr _GLOBAL_OFFSET_TABLE_[];

这个符号可能位于 .got 分区的中间，允许基于这个数组地址的负数或非负数索引访问。

函数地址
---------

在可执行文件和共享目标文件中引用一个函数的地址，可能不会解析到同一个值。在共享目标对象中，
动态链接器通常解析到该函数自己的虚拟地址上。而可执行文件中引用一个共享目标文件中的函数，
通常被链接编辑器解析到过程链接表条目的地址。

为了使函数地址的比较能正常工作，如果可执行文件引用了一个共享目标文件中的函数，链接编辑器
会将该函数对应的过程链接表条目的地址写入到函数符号中。动态链接器会特殊对待这种符号，当链
接编辑器搜索到该符号时，通常会按以下规则处理：

1. 如果符号的 st_shndx 字段不是 SHN_UNDEF，表示找到了该符号的定义，则使用 st_value 的
   值作为符号的地址
2. 如果 st_shndx 的值是 SHN_UNDEF，并且符号的类型是 STT_FUNC，st_value 的值不是 0，
   那么也是用 st_value 的值作为符号的地址
3. 否则，动态链接器认为这个符号在这个可执行文件中是未定义的，将继续处理

一个重定位被关联到链接过程表的条目中，这些条目用来直接函数调用而不是引用函数地址。这些重
定位不会按上面的规则特殊对待，因为动态链接器禁止将过程链接表条目重定向到它们自己身上。

过程链接表
-----------

类似于全局偏移表将位置无关的地址重定向到绝对地址，过程链接表将位置无关的函数调用重定向到
绝对地址。链接编辑器不能解决一个可执行目标到另一个的执行转移（例如函数调用），它只能将程
序的转移控制放到过程链接表条目中。

在 Intel386 架构中，过程链接表位于共享代码中，但是使用私有的全局偏移表中的地址。动态链
接器会确定目标的绝对地址并且据此修改全局偏移表的内存映像。从而可以重定向条目而不违反程序
代码的位置无关和共享。可执行文件和共享目标文件有各自的过程链接表。

绝对过程链接表： ::

    .PLT0: pushl got_plus_4
           jmp *got_plus_8
           nop; nop
           nop; nop
    .PLT1: jmp *name1_in_GOT
           pushl $offset
           jmp .PLT0@PC
    .PLT2: jmp *name2_in_GOT
           pushl $offset
           jmp .PLT0@PC
           ...

位置无关的过程链接表： ::

    .PLT0: pushl 4(%ebx)
           jmp *8(%ebx)
           nop; nop
           nop; nop
    .PLT1: jmp *name1@GOT(%ebx)
           pushl $offset
           jmp .PLT0@PC
    .PLT2: jmp *name2@GOT(%ebx)
           pushl $offset
           jmp .PLT0@PC
           ...

根据一些步骤，动态链接器和程序一起使用过程链接表和全局偏移表来解决符号引用：

1. 当第一次创建程序的内存映像时，动态链接器将全局便宜表的第二个和第三个条目设置为特殊值
2. 如果过程链接表时位置无关的，全局偏移表的地址必须位于 %ebx 寄存器中。每个进程映像中的
   共享目标文件都有自己的过程链接表，到一个过程链接表条目的控制转移只能发生在相同目标文
   件内部。因此，主调函数需要负责在调用过程链接表条目之前设置全局偏移表的基寄存器
3. 假如有一个名为 name1 的程序，它将控制权转移到标签 .PLT1
4. 第一条指令跳转到 name1 对应的全局偏移表条目的地址，初始化时全局偏移表保存的是下面的
   pushl 指令的地址，而不是 name1 的真正地址
5. 因此，程序将重定位偏移（offset）入栈，重定位偏移是一个32位的基于重定位表的字节偏移。
   对应的重定位类型是 R_386_JMP_SLOT，并且其中偏移字段的值就是对应的全局偏移表条目的偏
   移。重定位条目还包含符号索引，告诉动态链接器是哪个符号被引用，这里是 name1
6. 然后程序会跳转到 .PLT0，即过程链接表的第一个条目。pushl 指令会将第二个全局偏移表条目
   的值入栈，然后程序跳转到全局偏移表的第三个条目的地址，这时会将控制权交给动态链接器
7. 动态链接器接收到控制权后，它会展开栈，查看重定位条目，找到符号的值，将 name1 真实的
   地址保存到对应的全局偏移表条目中，并且将控制权转移给要求的目标

环境变量 LD_BIND_NOW 可以改变动态链接的值，如果这个值不为空，动态链接器会在将控制权交给
前程之前对过程链接表求值。也就是，动态链接器会在进程初始化时处理类型为 R_386_JMP_SLOT
的重定位条目。否则，动态链接器会延迟对过程链接表求值，会将符号解析和重定位推迟到过程链接
表条目的第一次执行。

延迟绑定会提高总体应用程序性能，因为未使用的符号不会引起额外的动态链接开销。然而，两种情
况使延迟绑定时对一些应用程序是不可接受的。第一种情况，因为动态链接器会拦截函数的调用来解
析对应的函数符号，一些应用程序受不了这种开销。第二种情况是，如果动态链接器找不到对应的符
号会终止程序，而在延迟绑定情况下，这种错误情况的发生是任意的，一些应用程序不能容忍这种不
确定性。通过关闭延迟绑定，动态链接器会在将控制权交给应用程序之前处理进程初始化时就强制报
出所有发生的错误。
